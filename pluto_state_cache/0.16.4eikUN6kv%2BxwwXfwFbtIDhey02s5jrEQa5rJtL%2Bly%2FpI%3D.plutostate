Œ¥bonds€¬cell_results‹Ù$e986c400-60e6-11eb-1b57-97ba3089c8c1ˆ¦queuedÂ±published_objects€§runningÂ¦output…¤bodyÚD|<div class="markdown"><h4><div id='Bonus' style='user-select: none; margin-top: 17px !important;'>BonusÂ : le sudoku en cours pour plusÂ tard...</div></h4>
<p>Je conseille de garder le code du sudoku en cours &#40;en cliquant, la copie est automatiqueÂ âœ¨&#41;.  <input type=button id='clÃ©gÃ©n' value='Copier le code Ã  garder :)'><input id='pour-dÃ©finir-le-sudoku-initial' type='text' style='font-size: x-small; margin-right: 2px; max-width: 38px;' /> <strong>Note</strong>Â :Â Ã Â collerÂ ailleurs dans un bloc-notes par exemple. </p>
<h5>...Ã  retrouver comme d&#39;autres vieux sudokusÂ :</h5>
<p>Ensuite, dans une &#40;nouvelle&#41; session, cliquer dans <em><code>EnterÂ cellÂ code...</code></em> tout en basÂ â†“ et coller le code qui fut gardÃ© &#40;cf. note ci-dessus&#41;. Enfin, lancer le code avec le boutonÂ â–¶ tout Ã  droite &#40;qui clignote justement&#41;.  Ce vieux sudoku est restorÃ© et en place du sudokuÂ initialÂ &#33; &#40;cela <a href="#ModifierInit">retourneÂ aussi enÂ hautÂ â†‘</a> de la page&#41;. </p>
<details open><summary style='list-style: none;'><h6 id='BonusAstuces' style='display:inline-block;user-select: none;'> Autres petites astucesÂ :</h6></summary><style>details[open] summary::after {content: ' (cliquer ici pour les cacher)';} summary:not(details[open] summary)::after {content: ' (cliquer ici pour les revoir)';}</style>
<ol>
<li><p>Modifier le premier sudoku &#40;Ã  vider si besoin, grÃ¢ce au premier choix&#41; et cocher ensuite ce que l&#39;on souhaite voir comme aide ou solutionÂ ; le sudoku du dessous rÃ©pond ainsi aux ordres. Cocher <code>ğŸ¤«Â CachÃ©e</code> pour revoir des indications sur l&#39;emploi des cases Ã  cocher. </p>
</li>
<li><p>En rÃ©alitÃ© en dehors de cellule ou de case, le fait de coller &#40;mÃªme en <a href="#BN">haut</a> de la page&#41; crÃ©e une cellule tout en bas &#40;en plus&#41;. Cela peut faire gagner un peu de temps. On peut mettre plusieurs vieux sudokusÂ : cependant seul le dernier, oÃ¹ le boutonÂ â–¶ fut appuyÃ©, est pris en compte. </p>
</li>
<li><p>Il est possible de <strong>remonter la solution</strong> au lieu du sudoku modifiable en cliquant sur l&#39;entÃªte <a href="#va_et_vient">Sudoku initialÂ â¤´ &#40;modifiable&#41; et sa solution</a>. On peut ensuite l&#39;enlever pour revenir au sudoku modifiable, â†ªÂ enÂ cliquant sur le texte sous la solution remontÃ©e. </p>
</li>
<li><p>Il est possible de bouger avec les flÃ¨ches, aller Ã  la ligne suivante automatiquement &#40;Ã  la <em><a href="https://www.google.com/search?q&#61;Snake">Snake</a></em>&#41;. Il y a aussi des raccourcis, comme <code>H</code>Â &#61;Â haut, <code>V</code> ou <code>G</code>Â &#61;Â gauche, <code>D</code> <code>J</code> <code>N</code>Â &#61;Â droite, <code>B</code>Â &#61;Â bas. Ni besoin de pavÃ© numÃ©rique, ni d&#39;appuyer sur <em>Majuscule</em>, les touches suivantes sont idendiques <code>1234Â 567Â 890</code> &#61; <code>AZERÂ TYUÂ IOP</code> &#61; <code>&amp;Ã©&quot;&#39;Â &#40;-Ã¨Â _Ã§Ã </code>. </p>
</li>
<li><p>Pour information, la fonction <strong>vieuxSudoku&#33;&#40;&#41;</strong> ou <strong>vieux&#40;&#41;</strong> sans paramÃ¨tre permet de gÃ©nÃ©rer un sudoku alÃ©atoire. En mettant uniquement un nombre en paramÃ¨tre, par exemple <strong>vieuxSudoku&#33;&#40;62&#41;</strong>Â : ce sera le nombre de cases vides du sudoku alÃ©atoire construit. Enfin, en mettant un intervalle, sous la forme <strong>dÃ©butÂ :Â fin</strong>, par exemple <strong>vieuxSudoku&#33;&#40;1:81&#41;</strong>Â : un nombre alÃ©atoire dans cet intervalle sera utilisÃ©. Pour tous ces sudokus alÃ©atoires, le fait de recliquer sur le boutonÂ â–¶ en gÃ©nÃ¨re un neuf. </p>
</li>
<li><p>Ce programme en <em>Julia</em> &#40;<a href="https://fr.wikipedia.org/wiki/Julia_&#40;langage_de_programmation&#41;">cf.Â wikipÃ©dia</a>&#41; est observable, d&#39;abord en cliquant sur <input type=button id='plutot' value='CeciÂ ğŸ“ğŸ¤“'> pour basculer l&#39;interface de <em>Pluto.jl</em>, puis en cliquant sur l&#39;Å“il ğŸ‘ Ã  cÃ´tÃ© de chaque cellule. Il est aussi possible de tÃ©lÃ©charger ce calepin <script>return html`<a href=${JSON.stringify(window.location.href).search('.html')>1 ? JSON.stringify(window.location.href).replace('html', 'jl') : JSON.stringify(window.location.href).replace('edit', 'notebookfile')} target='_blank' download>${document.title.replace('ğŸˆ ','').replace('â€” Pluto.jl','')}</a>`;</script> </p>
</li>
<li><p>Enfin, passer en style <strong>sombre</strong> ou <strong>lumineux</strong> en cliquant sur <a href="#Bonus"><strong>Bonus</strong></a> ou <span id='BoN' style='user-select: none;'>ğŸ˜</span> <a href="#BN">tout en haut</a>Â :&#41; </p>
</li>
</ol>
</details>
<script>
const plutÃ´tstylÃ© = `<link rel="stylesheet" href="./hide-ui.css" id="cachÃ©moiplutÃ´t"><style>
@media screen and (any-pointer: fine) {
    pluto-cell > pluto-runarea {
        // opacity: 0.5;
        opacity: 0;
        /* to make it feel smooth: */
        transition: opacity 0.25s ease-in-out;
    }
    pluto-cell > pluto-runarea > button:hover,
    pluto-cell:hover > pluto-runarea {
        opacity: 1;
        /* to make it feel snappy: */
        transition: opacity 0.05s ease-in-out;
    }
  //  pluto-cell > pluto-shoulder > button:hover {
  //      opacity: 0;
  //      /* to make it feel snappy: */
  //      transition: opacity 0.05s ease-in-out;
  //  } 
}

pluto-cell:not(.show_input) > pluto-runarea .runcell {
    display: none !important;
}
pluto-cell:not(.show_input) > pluto-runarea,
pluto-cell > pluto-runarea {
    display: block !important;
	background-color: unset;
}
preamble {
    display: none !important;
}
main {
	margin: 0 !important;
    padding: 0 !important;
    // padding-bottom: 4rem !important;
}
pluto-shoulder {
	// display: block !important;
	visibility:hidden;
    // left: -22px;
	// width: 0;
	// // width: 22px;
	// opacity: 0;
}
</style>`;
var stylÃ©cachÃ© = html`<span id="stylÃ©">${plutÃ´tstylÃ©}</span>`;
// var stylÃ©cachÃ© = html`<span id="stylÃ©"></span>`; // FAUX bidouille Ã  supprimer ////
function stylÃ©oupas() { 
	var stylÃ© = document.getElementById("stylÃ©");
	var cachÃ©moiplutÃ´t = document.getElementById("cachÃ©moiplutÃ´t");
	if (cachÃ©moiplutÃ´t) { 
		stylÃ©.innerHTML = '';
	} else {
		stylÃ©.innerHTML = plutÃ´tstylÃ©;
	};
};
document.getElementById("plutot").addEventListener("click", stylÃ©oupas);
return stylÃ©cachÃ©;
</script>
<script>
const plutÃ´tnoir = `<style>

/*///////////  Pour Pluto.jl  //////////////*/

	body {
		// background-color: hsl(0, 0%, 15%);
    	background-color: hsl(0, 0%, 0%);
	}
	// main {
		// max-width: 900px;
	// }

	body > header, footer, pluto-helpbox > header {
    	background-color: hsl(0, 0%, 8%);
		color: hsl(0, 0%, 90%);
	}
	body > header * {
		color: white;
	}
	preamble {
		filter: invert(1);
	}
	nav#at_the_top img {
		 filter: invert(1) hue-rotate(180deg) brightness(0.8) saturate(1.1);
	}
	nav#at_the_top button.toggle_export,
	nav#undo_delete {
		filter: invert(1);
	}
	body.disconnected > header {
		background-color: hsla(18, 35%, 47%, 50%);
	}
	pluto-input > button {
		filter: invert(1);
	}
	pluto-output {
		background-color: hsl(229, 5%, 10%);
		color: hsl(0, 0%, 90%);
	}
	pluto-output h1,
	pluto-output h2,
	pluto-output h3,
	pluto-output h4,
	pluto-output h5,
	pluto-output h6 {
		color: hsl(0, 0%, 90%);
	}
	pluto-output code {
		color: hsl(0, 0%, 80%)
	}
	pluto-output a {
		filter: invert(1);
	}
	pluto-output jltree, jltree *, jltree * * {
		filter: brightness(5);
	}
	nav#at_the_top img {
		filter: invert(1) hue-rotate(180deg) contrast(0.85);
	}
	jlerror > header {
		color: hsl(348, 40%, 90%);
	}
	pluto-filepicker .cm-s-material-palenight .cm-operator {
		color: #ff3b00;
	}
	jltree::before, jltree::after {
		filter: invert(1);
	}
	header.show_export header, header.show_export b {
		color: initial;
	}
	cell>button,
	cellinput>button,
	runarea>button,
	cellshoulder>button,
	slide-controls>button {
		color: white;
	}
	pluto-shoulder > button > span::after,
	pluto-cell.code_folded > pluto-shoulder > button > span::after {
		filter: invert(1);
	}
	pluto-cell > button {
		filter: invert(1);
	}
	cell.running > trafficlight {
		background: repeating-linear-gradient(-45deg,
		hsla(20, 20%, 80%, 1),
		hsla(20, 20%, 80%, 1) 8px,
		hsla(20, 20%, 80%, 0.1) 8px,
		hsla(20, 20%, 80%, 0.1) 16px);
	}
	cell.running.error > trafficlight {
		background: repeating-linear-gradient(-45deg,
            hsl(0, 100%, 71%),
            hsl(0, 100%, 71%) 8px,
            hsla(12, 71%, 47%, 0.33) 8px,
            hsla(12, 71%, 47%, 0.33) 16px);
	}
	pluto-runarea {
		filter: invert(1) brightness(1.9) contrast(1);
	}
	pluto-helpbox {
		color: hsl(0, 0%, 90%);
		background-color: hsl(0, 0%, 10%);
	}
	footer a {
		color: hsl(0, 0%, 95%);
	}
	footer input {
		background-color: hsl(0, 0%, 13%);
    	color: hsl(0, 0%, 85%);
	}
	pluto-helpbox > header > button {
		background: grey !important;
	}
	button {
		background-color: darkgrey;
	}
	div {
		background-color: #000000;
		color: #ded8d8;
	}
	a {
		color: #656060;
	}
	pluto-helpbox > section pre {
		background-color: #2f2f2f;
	}
	nav#at_the_top > #process_status {
		color: black;
		filter: invert(1);
	}
	#process_status > a {
		filter: invert(1);
	}
/*///////////  Pour le sudoku  //////////////*/

#taide,
#tesfoot,
#va_et_vient {
	user-select: none;
}
// #sudokufini {cursor: pointer;}
select{
  padding:10px;
}
table{
  width:0 !important;
  height:0 !important;
}
pluto-output table {
    border: medium hidden #000 !important;
	margin-block-start: 0;
	margin-block-end: 0;
}
pluto-output table.minitab {
	border-spacing: 0 !important;
    border: 0 !important;
	// margin: 1px !important;
	margin: auto !important;
}
tr {
  border:0 !important;
  width:0
}

td.even-color{
	background-color:#000; /* noir */
	text-align:center;
	font-size:14pt;
	width:38px; 
  	height:38px;
	border:1px solid #ccc; /* noir */
	// border:1px solid black;
	padding: 0;
}

td.odd-color{
	background-color:#222; /* noir */
	// background-color:#f2f2f2;
	text-align:center;
	font-size:14pt;
	border:1px solid #ccc; /* noir */
	// border:1px solid black;
	width:38px; 
  	height:38px;	
	padding: 0;			  
}
input#pour-dÃ©finir-le-sudoku-initial {
	background-color:transparent;
	border:0;
	margin-left:6px;
}
td input{
  text-align:center;
  font-size:14pt;
  width:100% !important;
  height:100% !important;
  background-color:transparent;
  border:0;
	color:#aaa; /* noir */
}
td { min-width: 38px; }

pluto-output table tr td.blur{
	color: transparent;
	user-select: none;
	// filter: blur(5px);
}

td.mini{
	min-width:15px; 
	// height:15px;
	// color: #b39700;
	padding: 0;
}
.minitab tbody tr:nth-child(2n+1) td:nth-child(2n+1) {
	color: #e6c300; /* noir */
	// color: #af0000;
	// 1 3 7 9
}
.minitab tbody tr:nth-child(2n) td:nth-child(2n) {
	color: #e6c300; /* noir */
	// color: #af0000;
	// 5
}
.minitab tbody tr:nth-child(2n+1) td:nth-child(2n) {
	color: #b39700; /* noir */
	// color: #da0000;
	// 2 8
}
.minitab tbody tr:nth-child(2n) td:nth-child(2n+1) {
	color: #b39700; /* noir */
	// color: #da0000;
	// 4 6
}
pluto-output table tr td table tr td.blur{
	// color: unset;
	color: transparent !important;
	// filter: blur(5px);
}

td.grandblur{
}
td.miniblur{
}
td.norbleu{
	font-weight: bold;
	color:#5668a4; /* noir */
	// color:#0064ff;
}
td.grandbleu{
	font-weight: bold;
	font-size: 18pt;
	color:#5668a4; /* noir */
	// color:#0064ff;
}

input[type="radio" i] {
		margin: 3px 3px 3px 0;
    }
.pasla{
	// visibility:hidden;
	filter: blur(3px);
}
.maistesou{
	// visibility:hidden;
	filter: blur(3px);
}

pluto-output.rich_output,
div {
		background-color: #000;
		color: #ded8d8;
	}

// div avant Pluto v0.14.5
.CodeMirror-lines,
.CodeMirror-linenumber,
.CodeMirror-gutter-elt,
.CodeMirror-gutter,
.CodeMirror-gutters {
		background-color: #000;
		color: #ded8d8;
    	border-right: solid 1px #000;
	}

code:not(pre code),
pluto-output.rich_output code {
    // padding: 3px;
    // border-radius: 2px;
    // background-color: #e4e4e4;
    background-color: #000;
    // border-top: solid 1px #9b9f9f;
    // border-left: solid 1px #9b9f9f;
	// box-shadow: 2px 2px #9b9f9f;
	// // box-shadow: 0.5px 0.5px 0px 1px #9b9f9f;
    border: solid 1px #9b9f9f;
	color: #9b9f9f;
} 
tr#lignenonvisible {
	border-top: medium solid black !important;
}
</style>`;
//////////////////////////////////////////////////////////////////////////////////////////
const plutÃ´tblanc = `<style id="cestblanc">
/*///////////  Pour le sudoku  //////////////*/

#taide,
#tesfoot,
#va_et_vient {
	user-select: none;
}
// #sudokufini {cursor: pointer;}
select{
  padding:10px;
}
table{
  width:0 !important;
  height:0 !important;
}
pluto-output table {
    border: medium hidden #000 !important;
	margin-block-start: 0;
	margin-block-end: 0;
}
pluto-output table.minitab {
	border-spacing: 0 !important;
    border: 0 !important;
	// margin: 1px !important;
	margin: auto !important;
}
tr {
  border:0 !important;
  width:0
}

td.even-color{
	// background-color:#000; /* noir */
	text-align:center;
	font-size:14pt;
	width:38px; 
  	height:38px;
	// border:1px solid #ccc; /* noir */
	border:1px solid black;
	padding: 0;
}

td.odd-color{
	// background-color:#222; /* noir */
	background-color:#f2f2f2;
	text-align:center;
	font-size:14pt;
	// border:1px solid #ccc; /* noir */
	border:1px solid black;
	width:38px; 
  	height:38px;	
	padding: 0;			  
}
input#pour-dÃ©finir-le-sudoku-initial {
	background-color:transparent;
	border:0;
	margin-left:6px;
}
td input{
  text-align:center;
  font-size:14pt;
  width:100% !important;
  height:100% !important;
  background-color:transparent;
  border:0;
	// color:#aaa; /* noir */
}
td { min-width: 38px; }

pluto-output table tr td.blur{
	color: transparent;
	user-select: none;
	// filter: blur(5px);
}

td.mini{
	min-width:15px; 
	// height:15px;
	// color: #b39700;
	padding: 0;
}
.minitab tbody tr:nth-child(2n+1) td:nth-child(2n+1) {
	// color: #e6c300; /* noir */
	color: #af0000;
	// 1 3 7 9
}
.minitab tbody tr:nth-child(2n) td:nth-child(2n) {
	// color: #e6c300; /* noir */
	color: #af0000;
	// 5
}
.minitab tbody tr:nth-child(2n+1) td:nth-child(2n) {
	// color: #b39700; /* noir */
	color: #da0000;
	// 2 8
}
.minitab tbody tr:nth-child(2n) td:nth-child(2n+1) {
	// color: #b39700; /* noir */
	color: #da0000;
	// 4 6
}
pluto-output table tr td table tr td.blur{
	// color: unset;
	color: transparent !important;
	// filter: blur(5px);
}

td.grandblur{
}
td.miniblur{
}
td.norbleu{
	font-weight: bold;
	// color:#5668a4; /* noir */
	color:#0064ff;
}
td.grandbleu{
	font-weight: bold;
	font-size: 18pt;
	// color:#5668a4; /* noir */
	color:#0064ff;
}

input[type="radio" i] {
		margin: 3px 3px 3px 0;
    }
.pasla{
	// visibility:hidden;
	filter: blur(3px);
}
.maistesou{
	// visibility:hidden;
	filter: blur(3px);
}
/* noir */ /*
pluto-output.rich_output,
div {
		background-color: #000;
		color: #ded8d8;
	}

// div avant Pluto v0.14.5
.CodeMirror-lines,
.CodeMirror-linenumber,
.CodeMirror-gutter-elt,
.CodeMirror-gutter,
.CodeMirror-gutters {
		background-color: #000;
		color: #ded8d8;
    	border-right: solid 1px #000;
	}

code:not(pre code),
pluto-output.rich_output code {
    // padding: 3px;
    // border-radius: 2px;
    // background-color: #e4e4e4;
    background-color: #000;
    // border-top: solid 1px #9b9f9f;
    // border-left: solid 1px #9b9f9f;
	// box-shadow: 2px 2px #9b9f9f;
	// // box-shadow: 0.5px 0.5px 0px 1px #9b9f9f;
    border: solid 1px #9b9f9f;
	color: #9b9f9f;
} */
tr#lignenonvisible {
	border-top: medium solid white !important;
}
</style>`;
var plutÃ´tstyle = html`<span id="stylebn">${plutÃ´tnoir}</span>`;
function noiroublanc() { 
	var stylebn = document.getElementById("stylebn");
	var cestblanc = document.getElementById("cestblanc");
	var BN = document.getElementById("BN");
	var BoN = document.getElementById("BoN");
	if (cestblanc) { 
		stylebn.innerHTML = plutÃ´tnoir;
		BN.innerHTML = "ğŸ˜";
		BoN.innerHTML = "ğŸ˜";
	} else {
		stylebn.innerHTML = plutÃ´tblanc;
		BN.innerHTML = "ğŸ˜‰";
		BoN.innerHTML = "ğŸ˜‰";
	};
};
// document.getElementById("BN").removeEventListener("click", noiroublanc);
document.getElementById("BN") ? document.getElementById("BN").addEventListener("click", noiroublanc) : true;
document.getElementById("BoN") ? document.getElementById("BoN").addEventListener("click", noiroublanc) : true;
document.getElementById("Bonus").addEventListener("click", noiroublanc);
return plutÃ´tstyle;
</script>
<script>
function gÃ©nÃ©rateurDeCodeClÃ©() {
  var copyText = document.getElementById("pour-dÃ©finir-le-sudoku-initial");
  var pastext = document.getElementById("sudokincipit");
  copyText.value = 'vieuxSudoku!(' + pastext.getAttribute('sudata') + ')';
  copyText.select();
  navigator.clipboard.writeText(copyText.value); // document.execCommand("copy");
}
document.getElementById("clÃ©gÃ©n").addEventListener("click", gÃ©nÃ©rateurDeCodeClÃ©);
	
var editCSS = document.createElement('style');
editCSS.id = "touslestemps";
var togglÃ© = "0";

let touslestemps = document.getElementsByClassName("runtime");
// touslestemps.forEach( e => { // ne fonctionne pas :'(
for(let j=0; j<(Object.keys(touslestemps).length); j++){
	touslestemps[j].addEventListener("click", (e) => {
		// alert(e.target.classList.toggle("opaqueoupas"));
		var stylÃ©t = document.getElementById("touslestemps");
		togglÃ© = (togglÃ©=="0") ? "0.7" : "0" ;
		stylÃ©t.innerHTML = "pluto-cell > pluto-runarea { opacity: "+ togglÃ© + "; }";
	});
};
return editCSS;
</script>
<p></p>
</div>°persist_js_stateÂ¤mime©text/html²last_run_timestampËAØ^}ş8‚¬rootassigneeÀ§cell_idÙ$e986c400-60e6-11eb-1b57-97ba3089c8c1¹depends_on_disabled_cellsÂ§runtimeÍïu§erroredÂÙ$caf45fd0-2797-11eb-2af5-e14c410d5144ˆ¦queuedÂ±published_objects€§runningÂ¦output…¤bodyÚÙ<div class="markdown"><p><bond def="viderOupas"><span id="ModifierInit" ><span style="display:inline-block;"><input type="radio" id="ModifierInitVider le sudoku initial" name="ModifierInit" value="Vider le sudoku initial" style="margin: O 4px 0 4px;" ><label style="margin: 0 18px 0 2px; user-select: none;" for="ModifierInitVider le sudoku initial">Vider le sudoku initial</label></span><span style="display:inline-block;"><input type="radio" id="ModifierInitLe sudoku initial ;)" name="ModifierInit" value="Le sudoku initial ;)" style="margin: O 4px 0 4px;" checked><label style="margin: 0 18px 0 2px; user-select: none;" for="ModifierInitLe sudoku initial ;)">Le sudoku initial ;)</label></span></span><script>const form = document.getElementById('ModifierInit')
form.oninput = (e) => { form.value = e.target.value; }
</script></bond> Â <a href='#Bonus' style='padding-left: 10px; border-left: medium dashed #777;'>BonusÂ plusÂ basÂ â†“</a>Â :Â vieuxÂ sudokuÂ etÂ astuces</p>
</div>°persist_js_stateÂ¤mime©text/html²last_run_timestampËAØ^}ÕT¬rootassigneeÀ§cell_idÙ$caf45fd0-2797-11eb-2af5-e14c410d5144¹depends_on_disabled_cellsÂ§runtimeÎñ$qÑ§erroredÂÙ$4c810c30-239f-11eb-09b6-cdc93fb56d2cˆ¦queuedÂ±published_objects€§runningÂ¦output…¤bodyÚ}<div class="markdown"><h5>ğŸ¤ Cela est cachÃ© pour le moment comme demandÃ©</h5>

<p>Bonne chance &#33; Si besoin, cocher <code>ğŸ¤«Â CachÃ©e</code> pour revoir ce message.</p>

<p>Pour information, <code>En touchant, entrevoir les nombresâ€¦</code> permet en cliquant de faire apparaÃ®tre &#40;et disparaÃ®tre via les chiffres bleus&#41; le contenu choisi, comme un coup de pouce. De plusÂ : </p>
<ul>
<li><p>En cliquant prÃ©cisÃ©ment dans une case, sur le 1Â &#40;enÂ haut Ã  gauche&#41; au 9Â &#40;enÂ bas Ã  droite; le chiffreÂ 5 est donc au milieu&#41;, les nombres <code>â€¦par chiffre possible</code> permettent de voir si le chiffre est possible dans la case et ses cases liÃ©es &#40;sur sa ligne, sa colonne et son carrÃ©&#41;.</p>
</li>
<li><p>Chaque case Ã  un seul nombre <code>â€¦de possibilitÃ©s &#40;minÂ âœ”&#41;</code> de 1 Ã  9 &#40;de faÃ§on similaire, de haut en bas dans la case&#41;. Celles ayant le moins de possibilitÃ©s ont âœ” en bas Ã  droite &#40;Ã  la place duÂ 9&#41;.</p>
</li>
<li><p>Les nombres <code>â€¦par caseÂ ğŸ”¢</code> permettent de voir la listeÂ complÃ¨teÂ des chiffres possibles par case.</p>
</li>
<li><p>Seuls les nombres <code>â€¦de la solutionÂ ğŸš©</code> montrent &#40;un ou&#41; des chiffres du sudoku fini.</p>
</li>
</ul>
<p>Bien sÃ»r, il y a pour chaque catÃ©gorieÂ :  <code>Pour toutes les cases, voir les nombresâ€¦</code> pour tout voir.</p>
</div>°persist_js_stateÂ¤mime©text/html²last_run_timestampËAØ^}ü’ó¬rootassigneeÀ§cell_idÙ$4c810c30-239f-11eb-09b6-cdc93fb56d2c¹depends_on_disabled_cellsÂ§runtimeÎ BÆâ§erroredÂÙ$bba0b550-2784-11eb-2f58-6bca9b1260d0ˆ¦queuedÂ±published_objects€§runningÂ¦output…¤bodyÚ&<div class="markdown"><bond def="voirOuPas"><span id="CacherRÃ©sultat" ><span style="display:inline-block;"><input type="radio" id="CacherRÃ©sultatğŸ¤«Â CachÃ©e" name="CacherRÃ©sultat" value="ğŸ¤«Â CachÃ©e" style="margin: O 4px 0 4px;" checked><label style="margin: 0 18px 0 2px; user-select: none;" for="CacherRÃ©sultatğŸ¤«Â CachÃ©e">ğŸ¤«Â CachÃ©e</label></span><span style="display:inline-block;"><input type="radio" id="CacherRÃ©sultatEn touchant, entrevoir les nombresâ€¦" name="CacherRÃ©sultat" value="En touchant, entrevoir les nombresâ€¦" style="margin: O 4px 0 4px;" ><label style="margin: 0 18px 0 2px; user-select: none;" for="CacherRÃ©sultatEn touchant, entrevoir les nombresâ€¦">En touchant, entrevoir les nombresâ€¦</label></span><span style="display:inline-block;"><input type="radio" id="CacherRÃ©sultatPour toutes les cases, voir les nombresâ€¦" name="CacherRÃ©sultat" value="Pour toutes les cases, voir les nombresâ€¦" style="margin: O 4px 0 4px;" ><label style="margin: 0 18px 0 2px; user-select: none;" for="CacherRÃ©sultatPour toutes les cases, voir les nombresâ€¦">Pour toutes les cases, voir les nombresâ€¦</label></span></span><script>const form = document.getElementById('CacherRÃ©sultat')
form.oninput = (e) => { form.value = e.target.value; if (e.target.value=='ğŸ¤«Â CachÃ©e') {
document.getElementById('PossiblesEtSolution').classList.add('pasla');
document.getElementById('puchoixÃ mettreenhaut').classList.add('pasla');
} else {
document.getElementById('PossiblesEtSolution').classList.remove('pasla');
document.getElementById('puchoixÃ mettreenhaut').classList.remove('pasla');
};}
</script></bond>
<div style='margin: 2px; border-bottom: medium dashed #777;'></div>
<bond def="PropalOuSoluce"><span id="PossiblesEtSolution" class="pasla"><span style="display:inline-block;"><input type="radio" id="PossiblesEtSolutionâ€¦par chiffre possible" name="PossiblesEtSolution" value="â€¦par chiffre possible" style="margin: O 4px 0 4px;" checked><label style="margin: 0 18px 0 2px; user-select: none;" for="PossiblesEtSolutionâ€¦par chiffre possible">â€¦par chiffre possible</label></span><span style="display:inline-block;"><input type="radio" id="PossiblesEtSolutionâ€¦de possibilitÃ©s (minÂ âœ”)" name="PossiblesEtSolution" value="â€¦de possibilitÃ©s (minÂ âœ”)" style="margin: O 4px 0 4px;" ><label style="margin: 0 18px 0 2px; user-select: none;" for="PossiblesEtSolutionâ€¦de possibilitÃ©s (minÂ âœ”)">â€¦de possibilitÃ©s (minÂ âœ”)</label></span><span style="display:inline-block;"><input type="radio" id="PossiblesEtSolutionâ€¦par caseÂ ğŸ”¢" name="PossiblesEtSolution" value="â€¦par caseÂ ğŸ”¢" style="margin: O 4px 0 4px;" ><label style="margin: 0 18px 0 2px; user-select: none;" for="PossiblesEtSolutionâ€¦par caseÂ ğŸ”¢">â€¦par caseÂ ğŸ”¢</label></span><span style="display:inline-block;"><input type="radio" id="PossiblesEtSolutionâ€¦de la solutionÂ ğŸš©" name="PossiblesEtSolution" value="â€¦de la solutionÂ ğŸš©" style="margin: O 4px 0 4px;" ><label style="margin: 0 18px 0 2px; user-select: none;" for="PossiblesEtSolutionâ€¦de la solutionÂ ğŸš©">â€¦de la solutionÂ ğŸš©</label></span></span><script>const form = document.getElementById('PossiblesEtSolution')
form.oninput = (e) => { form.value = e.target.value; if (e.target.value=='â€¦de possibilitÃ©s (minÂ âœ”)') {
document.getElementById('puchoixÃ mettreenhaut').classList.add('maistesou');
} else {
document.getElementById('puchoixÃ mettreenhaut').classList.remove('maistesou');
};}
</script></bond>
<div id='puchoixÃ mettreenhaut' class='pasla' style='margin-top: 10px;user-select: none;text-align: center;font-style: italic;font-weight: bold;color: #777'><input type='checkbox' id='choixÃ mettreenhaut' name='choixÃ mettreenhaut' ><label for='choixÃ mettreenhaut' style='margin-left: 2px;'>Cocher ici, puis toucher le chiffre Ã  mettre dans le sudokuÂ initial</label></div>
</div>°persist_js_stateÂ¤mime©text/html²last_run_timestampËAØ^}ôÛ¥¬rootassigneeÀ§cell_idÙ$bba0b550-2784-11eb-2f58-6bca9b1260d0¹depends_on_disabled_cellsÂ§runtimeÎm‘÷§erroredÂÙ$98f8cc2c-3a84-484a-b5cf-590b3f6a8fd0ˆ¦queuedÂ±published_objects€§runningÂ¦output…¤body °persist_js_stateÂ¤mimeªtext/plain²last_run_timestampËAØ^uU–¬rootassigneeÀ§cell_idÙ$98f8cc2c-3a84-484a-b5cf-590b3f6a8fd0¹depends_on_disabled_cellsÂ§runtimed§erroredÂÙ$43ec2840-239d-11eb-075a-071ac0d6f4d4ˆ¦queuedÂ±published_objects€§runningÂ¦output…¤body °persist_js_stateÂ¤mimeªtext/plain²last_run_timestampËAØ^|ª“S¬rootassigneeÀ§cell_idÙ$43ec2840-239d-11eb-075a-071ac0d6f4d4¹depends_on_disabled_cellsÂ§runtimeÎ:ú§erroredÂÙ$7cce8f50-2469-11eb-058a-099e8f6e3103ˆ¦queuedÂ±published_objects€§runningÂ¦output…¤bodyÚ<div class="markdown"><h4><script>
var vieillecopie = false;

function dÃ©jÃ vu() { 
	var pÃ¨re = document.getElementById("sudokincipit").parentElement;
	var fils = document.getElementById("copiefinie");
	var ancien = document.getElementById("sudokufini");
	if (vieillecopie.isEqualNode(ancien)) {
		ancien.innerHTML = fils.innerHTML;
		ancien.removeChild(ancien.querySelector("tfoot"));
		msga(ancien);
	}
	document.getElementById("sudokincipit").hidden = false;
	pÃ¨re.removeChild(fils);
	document.getElementById("va_et_vient").innerHTML = `Sudoku initialÂ â¤´ (modifiable) et sa solutionÂ : `
};

function lÃ haut() { 
	var pÃ¨re = document.getElementById("sudokincipit").parentElement;
	var fils = document.getElementById("copiefinie");
	var copie = document.getElementById("sudokufini");
	fils ? pÃ¨re.removeChild( fils ) : true;
	document.getElementById("sudokincipit").hidden = true;
	var tabl = document.createElement("table");
	vieillecopie = (copie ? copie.cloneNode(true) : tabl);
	tabl.id = "copiefinie";
	tabl.innerHTML = (copie ? copie.innerHTML : `<thead id='taide'><tr><td style='text-align: center;min-width: 340px;padding: 26px 0;'>Rien Ã  montrer, c'est cochÃ©Â Â <code>ğŸ¤«Â CachÃ©e</code></td></tr></thead>`) + `<tfoot id='tesfoot'><tr id='lignenonvisible'><th colspan="9">â†ª Cliquer ici pour revenir au sudoku modifiable</th></tr></tfoot>`;
	pÃ¨re.appendChild(tabl);
	document.getElementById("taide") ? document.getElementById("taide").addEventListener("click", dÃ©jÃ vu) : true;
	document.getElementById("tesfoot").addEventListener("click", dÃ©jÃ vu);
	copie ? msga(document.getElementById("copiefinie")) : true;
	document.getElementById("va_et_vient").innerHTML = `SolutionÂ â†‘ (au lieu du sudoku modifiableÂ initial)`
};
document.getElementById("va_et_vient").addEventListener("click", lÃ haut);

</script><span id="va_et_vient"> Sudoku initialÂ â¤´ &#40;modifiable&#41; et sa solutionÂ : </span></h4>
</div>°persist_js_stateÂ¤mime©text/html²last_run_timestampËAØ^}îP]¬rootassigneeÀ§cell_idÙ$7cce8f50-2469-11eb-058a-099e8f6e3103¹depends_on_disabled_cellsÂ§runtimeÍ<(§erroredÂÙ$81bbbd00-2c37-11eb-38a2-09eb78490a16ˆ¦queuedÂ±published_objects€§runningÂ¦output…¤bodyÚc<div class="markdown"><p>Si besoin, dans cette session, le sudoku en cours &#40;ci-dessous&#41; peut rester en mÃ©moire en cliquant sur le bouton suivant : <bond def="boutonSudokuInitial"><input type=button style='margin: 0 10px 0 10px;' value='En cours â†’ Le sudoku initial ;)'></bond> <em>&#40;Â siÂ videÂ â†’Â sudokuÂ alÃ©atoireÂ &#41;</em></p>
</div>°persist_js_stateÂ¤mime©text/html²last_run_timestampËAØ^|Ñø¶¬rootassigneeÀ§cell_idÙ$81bbbd00-2c37-11eb-38a2-09eb78490a16¹depends_on_disabled_cellsÂ§runtimeÎ Ğ¸§erroredÂÙ$96d2d3e0-2133-11eb-3f8b-7350f4cda025ˆ¦queuedÂ±published_objects€§runningÂ¦output…¤bodyÙz<div class="markdown"><h1>RÃ©soudre un Sudoku par AlexisÂ <span id='BN' style='user-select: none;'>ğŸ˜</span></h1>
</div>°persist_js_stateÂ¤mime©text/html²last_run_timestampËAØ^|ÄÉ“¬rootassigneeÀ§cell_idÙ$96d2d3e0-2133-11eb-3f8b-7350f4cda025¹depends_on_disabled_cellsÂ§runtimeÍ:˜§erroredÂÙ$b2cd0310-2663-11eb-11d4-49c8ce689142ˆ¦queuedÂ±published_objects€§runningÂ¦output…¤bodyÚ7<div class="markdown"><p><strong>Statistiques :</strong> il a fallu faire <strong>XX choix</strong> et <strong>YY tours</strong> &#40;si on savait Ã  l&#39;avance les bons choix&#41;, ce programme ayant fait <strong>ZZ tours</strong> au total en Î± essai pour rÃ©soudre ce sudoku &#33;&#33;&#33; ğŸ˜ƒ</p>
</div>°persist_js_stateÂ¤mime©text/html²last_run_timestampËAØ^}ö>¬rootassigneeÀ§cell_idÙ$b2cd0310-2663-11eb-11d4-49c8ce689142¹depends_on_disabled_cellsÂ§runtimeÍJ8§erroredÂÙ$a038b5b0-23a1-11eb-021d-ef7de773ef0eˆ¦queuedÂ±published_objects€§runningÂ¦output…¤bodyÚ!<bond def="bindJSudoku"><script>
// stylÃ©lÃ basavecbonus!

const premier = JSON.stringify( [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]] );
const deuxiÃ¨me = JSON.stringify( [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 2, 3, 4, 5, 0, 0, 0], [0, 2, 0, 0, 3, 0, 6, 0, 0], [0, 3, 4, 5, 6, 0, 0, 7, 0], [0, 6, 0, 0, 7, 0, 8, 0, 0], [0, 7, 0, 0, 8, 9, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]] );
const defaultFixedValues = [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 2, 3, 4, 5, 0, 0, 0], [0, 2, 0, 0, 3, 0, 6, 0, 0], [0, 3, 4, 5, 6, 0, 0, 7, 0], [0, 6, 0, 0, 7, 0, 8, 0, 0], [0, 7, 0, 0, 8, 9, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]]			
// const defaultFixedValues = [[0,0,0,7,0,0,0,0,0],[1,0,0,0,0,0,0,0,0],[0,0,0,4,3,0,2,0,0],[0,0,0,0,0,0,0,0,6],[0,0,0,5,0,9,0,0,0],[0,0,0,0,0,0,4,1,8],[0,0,0,0,8,1,0,0,0],[0,0,2,0,0,0,0,5,0],[0,4,0,0,0,0,3,0,0]];
		
window.createSudokuHtml = (values) => {
  const data = [];
  const htmlData = [];
  for(let i=0; i<9;i++){
    let htmlRow = [];
    data.push([]);
    for(let j=0; j<9;j++){
      const valuesLine = values[i];
      const value = valuesLine?valuesLine[j]:0;
      const htmlInput = html`<input  
        type='text'
        data-row='${i}'
        data-col='${j}'
        maxlength='1' 
        value='${(value||'')}'
      >`;
      const block = [Math.floor(i/3), Math.floor(j/3)];
      const isEven = ((block[0]+block[1])%2 === 0);
	  const isMedium = (j%3 === 0);
      const htmlCell = html`<td class='${isEven?"even-color":"odd-color"}' ${isMedium?'style="border-style:solid !important; border-left-width:medium !important;"':""}>${htmlInput}</td>`
      data[i][j] = value||0;
      htmlRow.push(htmlCell);
    }
	
    const isMediumBis = (i%3 === 0);
    htmlData.push(html`<tr ${isMediumBis?'style="border-style:solid !important; border-top-width:medium !important;"':""}>${htmlRow}</tr>`);
  }
  const _sudoku = html`<table id="sudokincipit" vrai="test" sudata=${JSON.stringify(data)} >
      <tbody>${htmlData}</tbody>
    </table>`  
  return {_sudoku,data};
  // // return _sudoku ;
  
}

window.sudokuViewReactiveValue = ({_sudoku:html, data}) => {
// // window.sudokuViewReactiveValue = (html) => {
// // data = JSON.parse(html.getAttribute("sudata"));
  html.addEventListener('input', (e)=>{
    e.stopPropagation();
    e.preventDefault();
    html.value = data
    return false;
  }); 
  
  let inputs = html.querySelectorAll('input');
  inputs.forEach(input => {
	
	const daligne = (e) => e.target.getAttribute('data-row');
	const dacol = (e) => e.target.getAttribute('data-col');
	const etp2 = (e) => e.target.parentElement.parentElement;
	const etp3 = (e) => e.target.parentElement.parentElement.parentElement;

	const moveDown = (e) => { 
		if (etp2(e).nextElementSibling == null) { 
		etp3(e).childNodes[0].childNodes[dacol(e)].childNodes[0].focus();
		} else { 
		etp2(e).nextElementSibling.childNodes[dacol(e)].childNodes[0].focus();
		} 
	}
	const moveUp = (e) => {
		if (etp2(e).previousElementSibling == null) { 
		etp3(e).lastChild.childNodes[dacol(e)].childNodes[0].focus();
		} else { 
		etp2(e).previousElementSibling.childNodes[dacol(e)].childNodes[0].focus();
		} 
	}
	const moveLeft = (e) => {
		if (e.target.parentElement.previousElementSibling == null) {
			if (etp2(e).previousElementSibling == null) {
				etp3(e).lastChild.lastChild.childNodes[0].focus();
			} else {
			etp2(e).previousElementSibling.lastChild.childNodes[0].focus();
		} } else {
		e.target.parentElement.previousElementSibling.childNodes[0].focus();
		} 
	}
	const moveRight = (e) => { 
		if (e.target.parentElement.nextElementSibling == null) {
			if (etp2(e).nextElementSibling == null) {
				etp3(e).childNodes[0].childNodes[0].childNodes[0].focus();
			} else {
			etp2(e).nextElementSibling.childNodes[0].childNodes[0].focus();
		} } else { 
		e.target.parentElement.nextElementSibling.childNodes[0].focus();
		} 
	}
		
	input.addEventListener('keydown',(e) => {
	  // e.target.focus();
	  e.target.select();
		
	  switch (e.key) {
		case "ArrowDown":
			moveDown(e);
			break;
		case "ArrowUp":
			moveUp(e);
			break;
		case "ArrowLeft":
			moveLeft(e);
			break;
		case "ArrowRight":
			moveRight(e);
			break;
		case "Shift":
		case "CapsLock":
		case "NumLock":
			break; // https://www.w3.org/TR/uievents-key/#keys-modifier
		case "Backspace":
		case "Delete":
			if (data[daligne(e)][dacol(e)] !== 0) {
				data[daligne(e)][dacol(e)] = 0;
				e.target.value = "";
				// Efface les puces car cela a Ã©tÃ© touchÃ©
				var ele = document.getElementsByName("ModifierInit");
				for(var ni=0;ni<ele.length;ni++)
					ele[ni].checked = false;
				const jdata = JSON.stringify(data);
				if (jdata == premier) {
					ele[0].checked = true;
				} else if (jdata == deuxiÃ¨me) {
					ele[1].checked = true;
				}
				html.setAttribute('sudata', jdata);
				html.dispatchEvent(new Event('input'));
			}
			(e.key==="Delete")?moveRight(e):moveLeft(e);
			var da = document.activeElement;
			(e.key==="Delete")?(da.selectionStart = da.selectionEnd = da.value.length):(da.selectionStart = da.selectionEnd = 0); // select KO :(
			break;
		default:
			return;
		} }) 
		
    input.addEventListener('input',(e) => {
	  const i = e.target.getAttribute('data-row'); // daligne(e)
	  const j = e.target.getAttribute('data-col'); // dacol(e)
	  const val = e.target.value //parseInt(e.target.value);
	  const oldata = data[i][j];

	  const bidouilliste = {a:1,z:2,e:3,r:4,t:5,y:6,u:7,i:8,o:9,
		A:1,Z:2,E:3,R:4,T:5,Y:6,U:7,I:8,O:9,
		'\&':1,Ã©:2,'"':3,"\'":4,'\(':5,'\-':6,Ã¨:7,_:8,Ã§:9};

	  const androidChromeEstChiant = {'b':moveDown,'B':moveDown,
		'h':moveUp,'H':moveUp,        'j':moveRight,'J':moveRight,
		'g':moveLeft,'G':moveLeft,'v':moveLeft,'V':moveLeft,
		'd':moveRight,'D':moveRight,'n':moveRight,'N':moveRight};

	  if (val in bidouilliste) {
		e.target.value = data[i][j] = bidouilliste[val];
	  } else if (val <= 9 && val >=1) {
		data[i][j] = parseInt(val);
		} else if ((val == 0)||(val == 'Ã ')||(val == 'p')||(val == 'P')) {
		data[i][j] = 0;
		e.target.value = '';
	  } else { 
		e.target.value = data[i][j] === 0 ? '' : data[i][j];
	  }

		if (oldata === data[i][j]) {
			e.stopPropagation();
			e.preventDefault();
		} else {
			// Efface les puces car cela a Ã©tÃ© touchÃ©
			var ele = document.getElementsByName("ModifierInit");
			for(var ni=0;ni<ele.length;ni++)
				ele[ni].checked = false;
			const jdata = JSON.stringify(data);
			if (jdata == premier) {
				ele[0].checked = true;
			} else if (jdata == deuxiÃ¨me) {
				ele[1].checked = true;
			}
			html.setAttribute('sudata', jdata);
			html.dispatchEvent(new Event('input'));
		}

		if (val in androidChromeEstChiant) {
			androidChromeEstChiant[val](e);
		} else {
			moveRight(e);
		}
		document.activeElement.select();
    })
		
    input.addEventListener('ctop',(e) => { // mis Ã  jour par chiffre sÃ©lectionnÃ©
	  const i = e.target.getAttribute('data-row'); // daligne(e)
	  const j = e.target.getAttribute('data-col'); // dacol(e)
	  const val = e.target.value //parseInt(e.target.value);
	  const oldata = data[i][j];

	  if (val <= 9 && val >=1) {
		data[i][j] = parseInt(val);
	  } else { 
		e.target.value = data[i][j] === 0 ? '' : data[i][j];
	  }

		if (oldata === data[i][j]) {
			e.stopPropagation();
			e.preventDefault();
		} else {
			// Efface les puces car cela a Ã©tÃ© touchÃ©
			var ele = document.getElementsByName("ModifierInit");
			for(var ni=0;ni<ele.length;ni++)
				ele[ni].checked = false;
			const jdata = JSON.stringify(data);
			if (jdata == premier) {
				ele[0].checked = true;
			} else if (jdata == deuxiÃ¨me) {
				ele[1].checked = true;
			}
			html.setAttribute('sudata', jdata);
			html.dispatchEvent(new Event('input'));
		}
    })
		
  }) 
  var ele = document.getElementsByName("ModifierInit");
  const jdata = JSON.stringify(data);
  if (jdata == premier) {
	ele[0].checked = true;
  } else if (jdata == deuxiÃ¨me) {
	ele[1].checked = true; // ...].click(); // Ã©tait KO...
  }
  html.setAttribute('sudata', jdata);
  html.dispatchEvent(new Event('input'));
  return html;

};

return sudokuViewReactiveValue(createSudokuHtml(defaultFixedValues));
</script></bond>°persist_js_stateÂ¤mime©text/html²last_run_timestampËAØ^}ìºä¬rootassigneeÀ§cell_idÙ$a038b5b0-23a1-11eb-021d-ef7de773ef0e¹depends_on_disabled_cellsÂ§runtimeÎ®¬§§erroredÂ±cell_dependencies‹Ù$e986c400-60e6-11eb-1b57-97ba3089c8c1„´precedence_heuristic	§cell_idÙ$e986c400-60e6-11eb-1b57-97ba3089c8c1´downstream_cells_map…µstylÃ©lÃ basavecbonus§calepin®bonusetastuces±pourgarderletemps¯pourvoirplutÃ´t²upstream_cells_mapŞ §@md_str­Base.getindex¯Markdown.Italic²Markdown.Paragraph®Base.Docs.HTML©@html_str²Markdown.Header{5}­Markdown.List¯Markdown.Config¨@raw_str­Markdown.Code²Markdown.Header{4}¢=>£Any¤Dict­Markdown.Link¤Base­Markdown.Bold¤HTML«Markdown.MD¥coool‘Ù$43ec2840-239d-11eb-075a-071ac0d6f4d4Ù$caf45fd0-2797-11eb-2af5-e14c410d5144„´precedence_heuristic	§cell_idÙ$caf45fd0-2797-11eb-2af5-e14c410d5144´downstream_cells_mapªviderOupas‘Ù$a038b5b0-23a1-11eb-021d-ef7de773ef0e²upstream_cells_mapŞ §@md_str­Base.getindex¥puces‘Ù$43ec2840-239d-11eb-075a-071ac0d6f4d4²Markdown.Paragraph®Base.Docs.HTML©@html_str¯Markdown.Config¹Main.PlutoRunner.Base.getÙ Main.PlutoRunner.Core.applicable¥@bind¤Dict¢=>£Any³boutonSudokuInitial‘Ù$81bbbd00-2c37-11eb-38a2-09eb78490a16¤Main¤BaseÙ!Main.PlutoRunner.PlutoRunner.Bond«Markdown.MD®sudokuinitial!‘Ù$43ec2840-239d-11eb-075a-071ac0d6f4d4Ù$4c810c30-239f-11eb-09b6-cdc93fb56d2c„´precedence_heuristic	§cell_idÙ$4c810c30-239f-11eb-09b6-cdc93fb56d2c´downstream_cells_mapªmaintenant²upstream_cells_map§@md_str«bindJSudoku‘Ù$a038b5b0-23a1-11eb-021d-ef7de773ef0e§Missing°htmlSudokuPropal‘Ù$43ec2840-239d-11eb-075a-071ac0d6f4d4®PropalOuSoluce‘Ù$bba0b550-2784-11eb-2f58-6bca9b1260d0«SudokuMÃ©mo‘Ù$43ec2840-239d-11eb-075a-071ac0d6f4d4¦String£isa±sudokuSolutionVue‘Ù$b2cd0310-2663-11eb-11d4-49c8ce689142¢==©voirOuPas‘Ù$bba0b550-2784-11eb-2f58-6bca9b1260d0ªhtmlSudoku‘Ù$43ec2840-239d-11eb-075a-071ac0d6f4d4¨getindexÙ$bba0b550-2784-11eb-2f58-6bca9b1260d0„´precedence_heuristic	§cell_idÙ$bba0b550-2784-11eb-2f58-6bca9b1260d0´downstream_cells_map‚®PropalOuSoluce‘Ù$4c810c30-239f-11eb-09b6-cdc93fb56d2c©voirOuPas‘Ù$4c810c30-239f-11eb-09b6-cdc93fb56d2c²upstream_cells_mapŞ §@md_str­Base.getindexÙ Main.PlutoRunner.Core.applicable®Base.Docs.HTML©@html_str¤Dict¯Markdown.Config¹Main.PlutoRunner.Base.get¥@bind¢=>£Any¤Main¤BaseÙ!Main.PlutoRunner.PlutoRunner.Bond«Markdown.MD¥puces‘Ù$43ec2840-239d-11eb-075a-071ac0d6f4d4Ù$98f8cc2c-3a84-484a-b5cf-590b3f6a8fd0„´precedence_heuristic	§cell_idÙ$98f8cc2c-3a84-484a-b5cf-590b3f6a8fd0´downstream_cells_map€²upstream_cells_map€Ù$43ec2840-239d-11eb-075a-071ac0d6f4d4„´precedence_heuristic§cell_idÙ$43ec2840-239d-11eb-075a-071ac0d6f4d4´downstream_cells_mapŞ >©sudokuAlt¢bt©kelcarrÃ©£jsm£rjs¥htmls¦htmatp¤nbcm¨interval©vaetvient‘Ù$7cce8f50-2469-11eb-058a-099e8f6e3103£pt2ªhtmlSudoku‘Ù$4c810c30-239f-11eb-09b6-cdc93fb56d2c©blindtest¯chiffrePossible®sudokuinitial!‘Ù$caf45fd0-2797-11eb-2af5-e14c410d5144°rÃ©soutSudokuMax¥puces’Ù$caf45fd0-2797-11eb-2af5-e14c410d5144Ù$bba0b550-2784-11eb-2f58-6bca9b1260d0¥set19°htmlSudokuPropal‘Ù$4c810c30-239f-11eb-09b6-cdc93fb56d2c«listecarrÃ©­rÃ©soutSudoku‘Ù$b2cd0310-2663-11eb-11d4-49c8ce689142«tuplecarrÃ©°matriceÃ listeJS£pt3¤carrµsimplechiffrePossible¤cool‘Ù$96d2d3e0-2133-11eb-3f8b-7350f4cda025¦uniclk¨shuffle!‘Ù$43ec2840-239d-11eb-075a-071ac0d6f4d4¤rmat¨nbPropal£sak¦carrÃ©£vs!£ini£mjs´sudokuAlÃ©atoireFini¤jsvd¥vieux°listeJSÃ matrice¤nbcj£vsd¤vues¥coool‘Ù$e986c400-60e6-11eb-1b57-97ba3089c8c1¥htmat¢vs¯vÃ©rifSudokuBon±pasAssezDePropal!§LUniclk¦defaut«SudokuMÃ©mo“Ù$a038b5b0-23a1-11eb-021d-ef7de773ef0eÙ$4c810c30-239f-11eb-09b6-cdc93fb56d2cÙ$b2cd0310-2663-11eb-11d4-49c8ce689142§suivant£sac¦testme¦htmlsp¬vieuxSudoku!£pt1­chiffrePropal°sudokuAlÃ©atoire¤salt£vS!§dÃ©faut²upstream_cells_mapŞ D²Markdown.Paragraph¡!²Markdown.Header{5}¡>¥Tuple¦union!§nothing¦length§delete!¡<¤copy¨deepcopy¦Vector§setdiff§isempty£Set­Base.getindex®Base.Docs.HTML¨setdiff!£div§collect¥zeros¦haskey¥union¢=>£Any£get¤rand£âˆ˜£isa¤Base¢<=­Markdown.Bold¥push!¡-£Int¡+¡*¨identity¨shuffle!‘Ù$43ec2840-239d-11eb-075a-071ac0d6f4d4¥Array¤Dict¦string¯Markdown.Italic§replace¯Markdown.Config¤pop!¤view¦String£map«Markdown.MD¥count¢!=¤fill¢==¢in©UnitRange¡:§Nothing©@html_str¤hcat¨@raw_str¤Bool­Markdown.Link¨nbzÃ©rof¤HTML§reshape¤get!Ù$7cce8f50-2469-11eb-058a-099e8f6e3103„´precedence_heuristic	§cell_idÙ$7cce8f50-2469-11eb-058a-099e8f6e3103´downstream_cells_map€²upstream_cells_map§@md_str­Base.getindex«bindJSudoku‘Ù$a038b5b0-23a1-11eb-021d-ef7de773ef0e®Base.Docs.HTML©@html_str¤Dict¯Markdown.Config²Markdown.Header{4}¢=>£Any¤Base©vaetvient‘Ù$43ec2840-239d-11eb-075a-071ac0d6f4d4«Markdown.MDÙ$81bbbd00-2c37-11eb-38a2-09eb78490a16„´precedence_heuristic	§cell_idÙ$81bbbd00-2c37-11eb-38a2-09eb78490a16´downstream_cells_map³boutonSudokuInitial‘Ù$caf45fd0-2797-11eb-2af5-e14c410d5144²upstream_cells_mapŞ §@md_str­Base.getindex¯Markdown.Italic²Markdown.Paragraph®Base.Docs.HTML©@html_str¯Markdown.Config¹Main.PlutoRunner.Base.getÙ Main.PlutoRunner.Core.applicable¥@bind¤Dict¢=>£Any¤Main¤BaseÙ!Main.PlutoRunner.PlutoRunner.Bond«Markdown.MDÙ$96d2d3e0-2133-11eb-3f8b-7350f4cda025„´precedence_heuristic	§cell_idÙ$96d2d3e0-2133-11eb-3f8b-7350f4cda025´downstream_cells_map€²upstream_cells_mapƒ§@md_str¤cool‘Ù$43ec2840-239d-11eb-075a-071ac0d6f4d4¨getindexÙ$b2cd0310-2663-11eb-11d4-49c8ce689142„´precedence_heuristic	§cell_idÙ$b2cd0310-2663-11eb-11d4-49c8ce689142´downstream_cells_map‚®sudokuSolution±sudokuSolutionVue‘Ù$4c810c30-239f-11eb-09b6-cdc93fb56d2c²upstream_cells_map‡§@md_str«bindJSudoku‘Ù$a038b5b0-23a1-11eb-021d-ef7de773ef0e£isa§Missing­rÃ©soutSudoku‘Ù$43ec2840-239d-11eb-075a-071ac0d6f4d4«SudokuMÃ©mo‘Ù$43ec2840-239d-11eb-075a-071ac0d6f4d4¨getindexÙ$a038b5b0-23a1-11eb-021d-ef7de773ef0e„´precedence_heuristic	§cell_idÙ$a038b5b0-23a1-11eb-021d-ef7de773ef0e´downstream_cells_mapƒ«bindJSudoku“Ù$7cce8f50-2469-11eb-058a-099e8f6e3103Ù$4c810c30-239f-11eb-09b6-cdc93fb56d2cÙ$b2cd0310-2663-11eb-11d4-49c8ce689142­SudokuInitial«viderSudoku²upstream_cells_mapÙ Main.PlutoRunner.Core.applicable§Missing¹Main.PlutoRunner.Base.get¨@raw_str¥@bind«SudokuMÃ©mo‘Ù$43ec2840-239d-11eb-075a-071ac0d6f4d4¤Main£isa¤HTMLÙ!Main.PlutoRunner.PlutoRunner.Bond¡*¢==ªviderOupas‘Ù$caf45fd0-2797-11eb-2af5-e14c410d5144´cell_execution_order›Ù$43ec2840-239d-11eb-075a-071ac0d6f4d4Ù$96d2d3e0-2133-11eb-3f8b-7350f4cda025Ù$81bbbd00-2c37-11eb-38a2-09eb78490a16Ù$caf45fd0-2797-11eb-2af5-e14c410d5144Ù$a038b5b0-23a1-11eb-021d-ef7de773ef0eÙ$7cce8f50-2469-11eb-058a-099e8f6e3103Ù$bba0b550-2784-11eb-2f58-6bca9b1260d0Ù$b2cd0310-2663-11eb-11d4-49c8ce689142Ù$4c810c30-239f-11eb-09b6-cdc93fb56d2cÙ$e986c400-60e6-11eb-1b57-97ba3089c8c1Ù$98f8cc2c-3a84-484a-b5cf-590b3f6a8fd0©shortpathªPlutoku.jl®process_status¥ready¤pathÙ8/home/runner/work/4LD.github.io/4LD.github.io/Plutoku.jlªcell_order›Ù$96d2d3e0-2133-11eb-3f8b-7350f4cda025Ù$caf45fd0-2797-11eb-2af5-e14c410d5144Ù$81bbbd00-2c37-11eb-38a2-09eb78490a16Ù$a038b5b0-23a1-11eb-021d-ef7de773ef0eÙ$7cce8f50-2469-11eb-058a-099e8f6e3103Ù$bba0b550-2784-11eb-2f58-6bca9b1260d0Ù$4c810c30-239f-11eb-09b6-cdc93fb56d2cÙ$b2cd0310-2663-11eb-11d4-49c8ce689142Ù$e986c400-60e6-11eb-1b57-97ba3089c8c1Ù$98f8cc2c-3a84-484a-b5cf-590b3f6a8fd0Ù$43ec2840-239d-11eb-075a-071ac0d6f4d4¥nbpkg‡²installed_versions¦Random¦stdlib°terminal_outputs¦RandomÙª[32m[1m  No Changes[22m[39m to `/tmp/jl_8dMWDk/Project.toml`
[32m[1m  No Changes[22m[39m to `/tmp/jl_8dMWDk/Manifest.toml`
[32m[1mLoading[22m[39m packages...
§enabledÃ·restart_recommended_msgÀ´restart_required_msgÀ­busy_packages¬instantiatedÃ«cell_inputs‹Ù$e986c400-60e6-11eb-1b57-97ba3089c8c1„§cell_idÙ$e986c400-60e6-11eb-1b57-97ba3089c8c1°running_disabledÂ¤codeÚBstylÃ©lÃ basavecbonus = HTML(raw"""<script>
const plutÃ´tnoir = `<style>

/*///////////  Pour Pluto.jl  //////////////*/

	body {
		// background-color: hsl(0, 0%, 15%);
    	background-color: hsl(0, 0%, 0%);
	}
	// main {
		// max-width: 900px;
	// }

	body > header, footer, pluto-helpbox > header {
    	background-color: hsl(0, 0%, 8%);
		color: hsl(0, 0%, 90%);
	}
	body > header * {
		color: white;
	}
	preamble {
		filter: invert(1);
	}
	nav#at_the_top img {
		 filter: invert(1) hue-rotate(180deg) brightness(0.8) saturate(1.1);
	}
	nav#at_the_top button.toggle_export,
	nav#undo_delete {
		filter: invert(1);
	}
	body.disconnected > header {
		background-color: hsla(18, 35%, 47%, 50%);
	}
	pluto-input > button {
		filter: invert(1);
	}
	pluto-output {
		background-color: hsl(229, 5%, 10%);
		color: hsl(0, 0%, 90%);
	}
	pluto-output h1,
	pluto-output h2,
	pluto-output h3,
	pluto-output h4,
	pluto-output h5,
	pluto-output h6 {
		color: hsl(0, 0%, 90%);
	}
	pluto-output code {
		color: hsl(0, 0%, 80%)
	}
	pluto-output a {
		filter: invert(1);
	}
	pluto-output jltree, jltree *, jltree * * {
		filter: brightness(5);
	}
	nav#at_the_top img {
		filter: invert(1) hue-rotate(180deg) contrast(0.85);
	}
	jlerror > header {
		color: hsl(348, 40%, 90%);
	}
	pluto-filepicker .cm-s-material-palenight .cm-operator {
		color: #ff3b00;
	}
	jltree::before, jltree::after {
		filter: invert(1);
	}
	header.show_export header, header.show_export b {
		color: initial;
	}
	cell>button,
	cellinput>button,
	runarea>button,
	cellshoulder>button,
	slide-controls>button {
		color: white;
	}
	pluto-shoulder > button > span::after,
	pluto-cell.code_folded > pluto-shoulder > button > span::after {
		filter: invert(1);
	}
	pluto-cell > button {
		filter: invert(1);
	}
	cell.running > trafficlight {
		background: repeating-linear-gradient(-45deg,
		hsla(20, 20%, 80%, 1),
		hsla(20, 20%, 80%, 1) 8px,
		hsla(20, 20%, 80%, 0.1) 8px,
		hsla(20, 20%, 80%, 0.1) 16px);
	}
	cell.running.error > trafficlight {
		background: repeating-linear-gradient(-45deg,
            hsl(0, 100%, 71%),
            hsl(0, 100%, 71%) 8px,
            hsla(12, 71%, 47%, 0.33) 8px,
            hsla(12, 71%, 47%, 0.33) 16px);
	}
	pluto-runarea {
		filter: invert(1) brightness(1.9) contrast(1);
	}
	pluto-helpbox {
		color: hsl(0, 0%, 90%);
		background-color: hsl(0, 0%, 10%);
	}
	footer a {
		color: hsl(0, 0%, 95%);
	}
	footer input {
		background-color: hsl(0, 0%, 13%);
    	color: hsl(0, 0%, 85%);
	}
	pluto-helpbox > header > button {
		background: grey !important;
	}
	button {
		background-color: darkgrey;
	}
	div {
		background-color: #000000;
		color: #ded8d8;
	}
	a {
		color: #656060;
	}
	pluto-helpbox > section pre {
		background-color: #2f2f2f;
	}
	nav#at_the_top > #process_status {
		color: black;
		filter: invert(1);
	}
	#process_status > a {
		filter: invert(1);
	}
/*///////////  Pour le sudoku  //////////////*/

#taide,
#tesfoot,
#va_et_vient {
	user-select: none;
}
// #sudokufini {cursor: pointer;}
select{
  padding:10px;
}
table{
  width:0 !important;
  height:0 !important;
}
pluto-output table {
    border: medium hidden #000 !important;
	margin-block-start: 0;
	margin-block-end: 0;
}
pluto-output table.minitab {
	border-spacing: 0 !important;
    border: 0 !important;
	// margin: 1px !important;
	margin: auto !important;
}
tr {
  border:0 !important;
  width:0
}

td.even-color{
	background-color:#000; /* noir */
	text-align:center;
	font-size:14pt;
	width:38px; 
  	height:38px;
	border:1px solid #ccc; /* noir */
	// border:1px solid black;
	padding: 0;
}

td.odd-color{
	background-color:#222; /* noir */
	// background-color:#f2f2f2;
	text-align:center;
	font-size:14pt;
	border:1px solid #ccc; /* noir */
	// border:1px solid black;
	width:38px; 
  	height:38px;	
	padding: 0;			  
}
input#pour-dÃ©finir-le-sudoku-initial {
	background-color:transparent;
	border:0;
	margin-left:6px;
}
td input{
  text-align:center;
  font-size:14pt;
  width:100% !important;
  height:100% !important;
  background-color:transparent;
  border:0;
	color:#aaa; /* noir */
}
td { min-width: 38px; }

pluto-output table tr td.blur{
	color: transparent;
	user-select: none;
	// filter: blur(5px);
}

td.mini{
	min-width:15px; 
	// height:15px;
	// color: #b39700;
	padding: 0;
}
.minitab tbody tr:nth-child(2n+1) td:nth-child(2n+1) {
	color: #e6c300; /* noir */
	// color: #af0000;
	// 1 3 7 9
}
.minitab tbody tr:nth-child(2n) td:nth-child(2n) {
	color: #e6c300; /* noir */
	// color: #af0000;
	// 5
}
.minitab tbody tr:nth-child(2n+1) td:nth-child(2n) {
	color: #b39700; /* noir */
	// color: #da0000;
	// 2 8
}
.minitab tbody tr:nth-child(2n) td:nth-child(2n+1) {
	color: #b39700; /* noir */
	// color: #da0000;
	// 4 6
}
pluto-output table tr td table tr td.blur{
	// color: unset;
	color: transparent !important;
	// filter: blur(5px);
}

td.grandblur{
}
td.miniblur{
}
td.norbleu{
	font-weight: bold;
	color:#5668a4; /* noir */
	// color:#0064ff;
}
td.grandbleu{
	font-weight: bold;
	font-size: 18pt;
	color:#5668a4; /* noir */
	// color:#0064ff;
}

input[type="radio" i] {
		margin: 3px 3px 3px 0;
    }
.pasla{
	// visibility:hidden;
	filter: blur(3px);
}
.maistesou{
	// visibility:hidden;
	filter: blur(3px);
}

pluto-output.rich_output,
div {
		background-color: #000;
		color: #ded8d8;
	}

// div avant Pluto v0.14.5
.CodeMirror-lines,
.CodeMirror-linenumber,
.CodeMirror-gutter-elt,
.CodeMirror-gutter,
.CodeMirror-gutters {
		background-color: #000;
		color: #ded8d8;
    	border-right: solid 1px #000;
	}

code:not(pre code),
pluto-output.rich_output code {
    // padding: 3px;
    // border-radius: 2px;
    // background-color: #e4e4e4;
    background-color: #000;
    // border-top: solid 1px #9b9f9f;
    // border-left: solid 1px #9b9f9f;
	// box-shadow: 2px 2px #9b9f9f;
	// // box-shadow: 0.5px 0.5px 0px 1px #9b9f9f;
    border: solid 1px #9b9f9f;
	color: #9b9f9f;
} 
tr#lignenonvisible {
	border-top: medium solid black !important;
}
</style>`;
//////////////////////////////////////////////////////////////////////////////////////////
const plutÃ´tblanc = `<style id="cestblanc">
/*///////////  Pour le sudoku  //////////////*/

#taide,
#tesfoot,
#va_et_vient {
	user-select: none;
}
// #sudokufini {cursor: pointer;}
select{
  padding:10px;
}
table{
  width:0 !important;
  height:0 !important;
}
pluto-output table {
    border: medium hidden #000 !important;
	margin-block-start: 0;
	margin-block-end: 0;
}
pluto-output table.minitab {
	border-spacing: 0 !important;
    border: 0 !important;
	// margin: 1px !important;
	margin: auto !important;
}
tr {
  border:0 !important;
  width:0
}

td.even-color{
	// background-color:#000; /* noir */
	text-align:center;
	font-size:14pt;
	width:38px; 
  	height:38px;
	// border:1px solid #ccc; /* noir */
	border:1px solid black;
	padding: 0;
}

td.odd-color{
	// background-color:#222; /* noir */
	background-color:#f2f2f2;
	text-align:center;
	font-size:14pt;
	// border:1px solid #ccc; /* noir */
	border:1px solid black;
	width:38px; 
  	height:38px;	
	padding: 0;			  
}
input#pour-dÃ©finir-le-sudoku-initial {
	background-color:transparent;
	border:0;
	margin-left:6px;
}
td input{
  text-align:center;
  font-size:14pt;
  width:100% !important;
  height:100% !important;
  background-color:transparent;
  border:0;
	// color:#aaa; /* noir */
}
td { min-width: 38px; }

pluto-output table tr td.blur{
	color: transparent;
	user-select: none;
	// filter: blur(5px);
}

td.mini{
	min-width:15px; 
	// height:15px;
	// color: #b39700;
	padding: 0;
}
.minitab tbody tr:nth-child(2n+1) td:nth-child(2n+1) {
	// color: #e6c300; /* noir */
	color: #af0000;
	// 1 3 7 9
}
.minitab tbody tr:nth-child(2n) td:nth-child(2n) {
	// color: #e6c300; /* noir */
	color: #af0000;
	// 5
}
.minitab tbody tr:nth-child(2n+1) td:nth-child(2n) {
	// color: #b39700; /* noir */
	color: #da0000;
	// 2 8
}
.minitab tbody tr:nth-child(2n) td:nth-child(2n+1) {
	// color: #b39700; /* noir */
	color: #da0000;
	// 4 6
}
pluto-output table tr td table tr td.blur{
	// color: unset;
	color: transparent !important;
	// filter: blur(5px);
}

td.grandblur{
}
td.miniblur{
}
td.norbleu{
	font-weight: bold;
	// color:#5668a4; /* noir */
	color:#0064ff;
}
td.grandbleu{
	font-weight: bold;
	font-size: 18pt;
	// color:#5668a4; /* noir */
	color:#0064ff;
}

input[type="radio" i] {
		margin: 3px 3px 3px 0;
    }
.pasla{
	// visibility:hidden;
	filter: blur(3px);
}
.maistesou{
	// visibility:hidden;
	filter: blur(3px);
}
/* noir */ /*
pluto-output.rich_output,
div {
		background-color: #000;
		color: #ded8d8;
	}

// div avant Pluto v0.14.5
.CodeMirror-lines,
.CodeMirror-linenumber,
.CodeMirror-gutter-elt,
.CodeMirror-gutter,
.CodeMirror-gutters {
		background-color: #000;
		color: #ded8d8;
    	border-right: solid 1px #000;
	}

code:not(pre code),
pluto-output.rich_output code {
    // padding: 3px;
    // border-radius: 2px;
    // background-color: #e4e4e4;
    background-color: #000;
    // border-top: solid 1px #9b9f9f;
    // border-left: solid 1px #9b9f9f;
	// box-shadow: 2px 2px #9b9f9f;
	// // box-shadow: 0.5px 0.5px 0px 1px #9b9f9f;
    border: solid 1px #9b9f9f;
	color: #9b9f9f;
} */
tr#lignenonvisible {
	border-top: medium solid white !important;
}
</style>`;
var plutÃ´tstyle = html`<span id="stylebn">${plutÃ´tnoir}</span>`;
function noiroublanc() { 
	var stylebn = document.getElementById("stylebn");
	var cestblanc = document.getElementById("cestblanc");
	var BN = document.getElementById("BN");
	var BoN = document.getElementById("BoN");
	if (cestblanc) { 
		stylebn.innerHTML = plutÃ´tnoir;
		BN.innerHTML = "ğŸ˜";
		BoN.innerHTML = "ğŸ˜";
	} else {
		stylebn.innerHTML = plutÃ´tblanc;
		BN.innerHTML = "ğŸ˜‰";
		BoN.innerHTML = "ğŸ˜‰";
	};
};
// document.getElementById("BN").removeEventListener("click", noiroublanc);
document.getElementById("BN") ? document.getElementById("BN").addEventListener("click", noiroublanc) : true;
document.getElementById("BoN") ? document.getElementById("BoN").addEventListener("click", noiroublanc) : true;
document.getElementById("Bonus").addEventListener("click", noiroublanc);
return plutÃ´tstyle;
</script>"""); pourvoirplutÃ´t = HTML(raw"""<script>
const plutÃ´tstylÃ© = `<link rel="stylesheet" href="./hide-ui.css" id="cachÃ©moiplutÃ´t"><style>
@media screen and (any-pointer: fine) {
    pluto-cell > pluto-runarea {
        // opacity: 0.5;
        opacity: 0;
        /* to make it feel smooth: */
        transition: opacity 0.25s ease-in-out;
    }
    pluto-cell > pluto-runarea > button:hover,
    pluto-cell:hover > pluto-runarea {
        opacity: 1;
        /* to make it feel snappy: */
        transition: opacity 0.05s ease-in-out;
    }
  //  pluto-cell > pluto-shoulder > button:hover {
  //      opacity: 0;
  //      /* to make it feel snappy: */
  //      transition: opacity 0.05s ease-in-out;
  //  } 
}

pluto-cell:not(.show_input) > pluto-runarea .runcell {
    display: none !important;
}
pluto-cell:not(.show_input) > pluto-runarea,
pluto-cell > pluto-runarea {
    display: block !important;
	background-color: unset;
}
preamble {
    display: none !important;
}
main {
	margin: 0 !important;
    padding: 0 !important;
    // padding-bottom: 4rem !important;
}
pluto-shoulder {
	// display: block !important;
	visibility:hidden;
    // left: -22px;
	// width: 0;
	// // width: 22px;
	// opacity: 0;
}
</style>`;
var stylÃ©cachÃ© = html`<span id="stylÃ©">${plutÃ´tstylÃ©}</span>`;
// var stylÃ©cachÃ© = html`<span id="stylÃ©"></span>`; // FAUX bidouille Ã  supprimer ////
function stylÃ©oupas() { 
	var stylÃ© = document.getElementById("stylÃ©");
	var cachÃ©moiplutÃ´t = document.getElementById("cachÃ©moiplutÃ´t");
	if (cachÃ©moiplutÃ´t) { 
		stylÃ©.innerHTML = '';
	} else {
		stylÃ©.innerHTML = plutÃ´tstylÃ©;
	};
};
document.getElementById("plutot").addEventListener("click", stylÃ©oupas);
return stylÃ©cachÃ©;
</script>"""); calepin = HTML(raw"<script>return html`<a href=${JSON.stringify(window.location.href).search('.html')>1 ? JSON.stringify(window.location.href).replace('html', 'jl') : JSON.stringify(window.location.href).replace('edit', 'notebookfile')} target='_blank' download>${document.title.replace('ğŸˆ ','').replace('â€” Pluto.jl','')}</a>`;</script>"); pourgarderletemps = HTML(raw"""<script>
	function gÃ©nÃ©rateurDeCodeClÃ©() {
	  var copyText = document.getElementById("pour-dÃ©finir-le-sudoku-initial");
	  var pastext = document.getElementById("sudokincipit");
	  copyText.value = 'vieuxSudoku!(' + pastext.getAttribute('sudata') + ')';
	  copyText.select();
	  navigator.clipboard.writeText(copyText.value); // document.execCommand("copy");
	}
	document.getElementById("clÃ©gÃ©n").addEventListener("click", gÃ©nÃ©rateurDeCodeClÃ©);
		
	var editCSS = document.createElement('style');
	editCSS.id = "touslestemps";
	var togglÃ© = "0";
	
	let touslestemps = document.getElementsByClassName("runtime");
	// touslestemps.forEach( e => { // ne fonctionne pas :'(
	for(let j=0; j<(Object.keys(touslestemps).length); j++){
		touslestemps[j].addEventListener("click", (e) => {
			// alert(e.target.classList.toggle("opaqueoupas"));
			var stylÃ©t = document.getElementById("touslestemps");
			togglÃ© = (togglÃ©=="0") ? "0.7" : "0" ;
			stylÃ©t.innerHTML = "pluto-cell > pluto-runarea { opacity: "+ togglÃ© + "; }";
		});
	};
	return editCSS;
	</script>"""); bonusetastuces = md"""#### $(html"<div id='Bonus' style='user-select: none; margin-top: 17px !important;'>BonusÂ : le sudoku en cours pour plusÂ tard...</div>") 
Je conseille de garder le code du sudoku en cours (en cliquant, la copie est automatiqueÂ âœ¨). 
$(html"<input type=button id='clÃ©gÃ©n' value='Copier le code Ã  garder :)'><input id='pour-dÃ©finir-le-sudoku-initial' type='text' style='font-size: x-small; margin-right: 2px; max-width: 38px;' />") **Note**Â :Â Ã Â collerÂ ailleurs dans un bloc-notes par exemple. 

##### ...Ã  retrouver comme d'autres vieux sudokusÂ : 

Ensuite, dans une (nouvelle) session, cliquer dans _`EnterÂ cellÂ code...`_ tout en basÂ â†“ et coller le code qui fut gardÃ© (cf. note ci-dessus).
Enfin, lancer le code avec le boutonÂ â–¶ tout Ã  droite (qui clignote justement). 
Ce vieux sudoku est restorÃ© et en place du sudokuÂ initialÂ ! (cela [retourneÂ aussi enÂ hautÂ â†‘](#ModifierInit) de la page). 
	
$(html"<details open><summary style='list-style: none;'><h6 id='BonusAstuces' style='display:inline-block;user-select: none;'> Autres petites astucesÂ :</h6></summary><style>details[open] summary::after {content: ' (cliquer ici pour les cacher)';} summary:not(details[open] summary)::after {content: ' (cliquer ici pour les revoir)';}</style>")
   1. Modifier le premier sudoku (Ã  vider si besoin, grÃ¢ce au premier choix) et cocher ensuite ce que l'on souhaite voir comme aide ou solutionÂ ; le sudoku du dessous rÃ©pond ainsi aux ordres. Cocher `ğŸ¤«Â CachÃ©e` pour revoir des indications sur l'emploi des cases Ã  cocher. 
   2. En rÃ©alitÃ© en dehors de cellule ou de case, le fait de coller (mÃªme en [haut](#BN) de la page) crÃ©e une cellule tout en bas (en plus). Cela peut faire gagner un peu de temps. On peut mettre plusieurs vieux sudokusÂ : cependant seul le dernier, oÃ¹ le boutonÂ â–¶ fut appuyÃ©, est pris en compte. 
   3. Il est possible de **remonter la solution** au lieu du sudoku modifiable en cliquant sur l'entÃªte [Sudoku initialÂ â¤´ (modifiable) et sa solution](#va_et_vient). On peut ensuite l'enlever pour revenir au sudoku modifiable, â†ªÂ enÂ cliquant sur le texte sous la solution remontÃ©e. 
   4. Il est possible de bouger avec les flÃ¨ches, aller Ã  la ligne suivante automatiquement (Ã  la _[Snake](https://www.google.com/search?q=Snake)_). Il y a aussi des raccourcis, comme `H`Â =Â haut, `V` ou `G`Â =Â gauche, `D` `J` `N`Â =Â droite, `B`Â =Â bas. Ni besoin de pavÃ© numÃ©rique, ni d'appuyer sur _Majuscule_, les touches suivantes sont idendiques `1234Â 567Â 890` = `AZERÂ TYUÂ IOP` = `&Ã©"'Â (-Ã¨Â _Ã§Ã `. 
   5. Pour information, la fonction **vieuxSudoku!()** ou **vieux()** sans paramÃ¨tre permet de gÃ©nÃ©rer un sudoku alÃ©atoire. En mettant uniquement un nombre en paramÃ¨tre, par exemple **vieuxSudoku!(62)**Â : ce sera le nombre de cases vides du sudoku alÃ©atoire construit. Enfin, en mettant un intervalle, sous la forme **dÃ©butÂ :Â fin**, par exemple **vieuxSudoku!(1:81)**Â : un nombre alÃ©atoire dans cet intervalle sera utilisÃ©. Pour tous ces sudokus alÃ©atoires, le fait de recliquer sur le boutonÂ â–¶ en gÃ©nÃ¨re un neuf. 
   6. Ce programme en _Julia_ ([cf.Â wikipÃ©dia](https://fr.wikipedia.org/wiki/Julia_(langage_de_programmation))) est observable, d'abord en cliquant sur $(html"<input type=button id='plutot' value='CeciÂ ğŸ“ğŸ¤“'>") pour basculer l'interface de _Pluto.jl_, puis en cliquant sur l'Å“il ğŸ‘ Ã  cÃ´tÃ© de chaque cellule. Il est aussi possible de tÃ©lÃ©charger ce calepin $calepin 
   7. Enfin, passer en style **sombre** ou **lumineux** en cliquant sur [**Bonus**](#Bonus) ou $coool [tout en haut](#BN)Â :) 
$(html"</details>")
$pourvoirplutÃ´t 
$stylÃ©lÃ basavecbonus
$pourgarderletemps
	"""«code_foldedÃÙ$caf45fd0-2797-11eb-2af5-e14c410d5144„§cell_idÙ$caf45fd0-2797-11eb-2af5-e14c410d5144°running_disabledÂ¤codeÚÇbegin 
	boutonSudokuInitial # Remettre le puce "ModifierInit" sur Le sudoku initial ;)
	sudokuinitial!() # vieuxSudoku!(SudokuMÃ©mo[3]) Pour remplacer par celui modifiÃ©
	md""" $(@bind viderOupas puces(["Vider le sudoku initial","Le sudoku initial ;)"],"Le sudoku initial ;)"; idPuces="ModifierInit")) $(html"Â <a href='#Bonus' style='padding-left: 10px; border-left: medium dashed #777;'>BonusÂ plusÂ basÂ â†“</a>")Â :Â vieuxÂ sudokuÂ etÂ astuces
"""
end«code_foldedÃÙ$4c810c30-239f-11eb-09b6-cdc93fb56d2c„§cell_idÙ$4c810c30-239f-11eb-09b6-cdc93fb56d2c°running_disabledÂ¤codeÚGbegin
	if bindJSudoku isa Missing ### || valeur isa Missing
		maintenant = SudokuMÃ©mo[3]
	else maintenant = bindJSudoku ### matriceÃ listeJS(histoire[valeur])
	end
	if voirOuPas isa Missing || voirOuPas=="ğŸ¤«Â CachÃ©e" # || bindJSudoku isa Missing || valeur isa Missing
		md"""$(sudokuSolutionVue isa String ? md"##### ğŸ¤ Cela est cachÃ© pour le moment comme demandÃ© âš¡"  : md"##### ğŸ¤ Cela est cachÃ© pour le moment comme demandÃ©")
$(sudokuSolutionVue isa String ? md"Pas de bol ! Cf. la remarque en gras plus bas. Si besoin, cocher `ğŸ¤«Â CachÃ©e` pour revoir ceci."  : md"Bonne chance ! Si besoin, cocher `ğŸ¤«Â CachÃ©e` pour revoir ce message.")

Pour information, `En touchant, entrevoir les nombresâ€¦` permet en cliquant de faire apparaÃ®tre (et disparaÃ®tre via les chiffres bleus) le contenu choisi, comme un coup de pouce. De plusÂ : 

   - En cliquant prÃ©cisÃ©ment dans une case, sur le 1Â (enÂ haut Ã  gauche) au 9Â (enÂ bas Ã  droite; le chiffreÂ 5 est donc au milieu), les nombres `â€¦par chiffre possible` permettent de voir si le chiffre est possible dans la case et ses cases liÃ©es (sur sa ligne, sa colonne et son carrÃ©).
   - Chaque case Ã  un seul nombre `â€¦de possibilitÃ©s (minÂ âœ”)` de 1 Ã  9 (de faÃ§on similaire, de haut en bas dans la case). Celles ayant le moins de possibilitÃ©s ont âœ” en bas Ã  droite (Ã  la place duÂ 9).
   - Les nombres `â€¦par caseÂ ğŸ”¢` permettent de voir la listeÂ complÃ¨teÂ des chiffres possibles par case.
   - Seuls les nombres `â€¦de la solutionÂ ğŸš©` montrent (un ou) des chiffres du sudoku fini.

Bien sÃ»r, il y a pour chaque catÃ©gorieÂ : 
`Pour toutes les cases, voir les nombresâ€¦` pour tout voir."""
	elseif PropalOuSoluce == "â€¦de la solutionÂ ğŸš©" # || PropalOuSoluce isa Missing
		htmlSudoku(sudokuSolutionVue,maintenant ; toutVoir= (voirOuPas=="Pour toutes les cases, voir les nombresâ€¦") )
	else htmlSudokuPropal(maintenant,sudokuSolutionVue ; toutVoir= (voirOuPas=="Pour toutes les cases, voir les nombresâ€¦"), parCase= (PropalOuSoluce =="â€¦par caseÂ ğŸ”¢"), somme= (PropalOuSoluce=="â€¦de possibilitÃ©s (minÂ âœ”)"))
	end
end«code_foldedÃÙ$bba0b550-2784-11eb-2f58-6bca9b1260d0„§cell_idÙ$bba0b550-2784-11eb-2f58-6bca9b1260d0°running_disabledÂ¤codeÚ´#=
md"""$(@bind voirOuPas puces(["ğŸ¤«Â CachÃ©e", "En touchant, entrevoir les nombresâ€¦","Pour toutes les cases, voir les nombresâ€¦"],"Pour toutes les cases, voir les nombresâ€¦"; idPuces="CacherRÃ©sultat") ) 

$(html"<div style='margin: 2px; border-bottom: medium dashed #777;'></div>")
                                                
$(@bind PropalOuSoluce puces(["â€¦par chiffre possible", "â€¦de possibilitÃ©s (minÂ âœ”)","â€¦par caseÂ ğŸ”¢","â€¦de la solutionÂ ğŸš©"],"â€¦de la solutionÂ ğŸš©"; idPuces="PossiblesEtSolution", classe="" ) ) =#
md"""$(@bind voirOuPas puces(["ğŸ¤«Â CachÃ©e", "En touchant, entrevoir les nombresâ€¦","Pour toutes les cases, voir les nombresâ€¦"],"ğŸ¤«Â CachÃ©e"; idPuces="CacherRÃ©sultat") ) 

$(html"<div style='margin: 2px; border-bottom: medium dashed #777;'></div>")
                                                
$(@bind PropalOuSoluce puces(["â€¦par chiffre possible", "â€¦de possibilitÃ©s (minÂ âœ”)","â€¦par caseÂ ğŸ”¢","â€¦de la solutionÂ ğŸš©"],"â€¦par chiffre possible"; idPuces="PossiblesEtSolution", classe="pasla" ) )

$(html"<div id='puchoixÃ mettreenhaut' class='pasla' style='margin-top: 10px;user-select: none;text-align: center;font-style: italic;font-weight: bold;color: #777'><input type='checkbox' id='choixÃ mettreenhaut' name='choixÃ mettreenhaut' ><label for='choixÃ mettreenhaut' style='margin-left: 2px;'>Cocher ici, puis toucher le chiffre Ã  mettre dans le sudokuÂ initial</label></div>")"""«code_foldedÃÙ$98f8cc2c-3a84-484a-b5cf-590b3f6a8fd0„§cell_idÙ$98f8cc2c-3a84-484a-b5cf-590b3f6a8fd0°running_disabledÂ¤code «code_foldedÂÙ$43ec2840-239d-11eb-075a-071ac0d6f4d4„§cell_idÙ$43ec2840-239d-11eb-075a-071ac0d6f4d4°running_disabledÂ¤codeÚşíbegin 
	# @bind bindJSudoku SudokuInitial # et son javascript est inclus au plus haut
	# stylÃ©lÃ basavecbonus! ## voir juste dans la cellule #Bonus au dessus â†‘
	
	const set19 = Set(1:9) # Pour ne pas le recalculer Ã  chaque fois
	const cool = html"<span id='BN' style='user-select: none;'>ğŸ˜</span>";
	const coool = html"<span id='BoN' style='user-select: none;'>ğŸ˜</span>"
	jsvd() = fill(fill(0,9),9) # JSvide ou JCVD ^^ pseudo const
	const suivant = [401, 801, 1] # 81 pour le premier (dans la fonction rÃ©soutSudoku)
	using Random: shuffle! # Astuce pour Ãªtre encore plus rapide = Fast & Furious
	## shuffle!(x) = x ## Si besoin, mais... Everyday I shuffling ! (dixit LMFAO)

	SudokuMÃ©mo=[[[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0]],
	[[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,1,2,3,4,5,0,0,0],[0,2,0,0,3,0,6,0,0],[0,3,4,5,6,0,0,7,0],[0,6,0,0,7,0,8,0,0],[0,7,0,0,8,9,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0]],
	[[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,1,2,3,4,5,0,0,0],[0,2,0,0,3,0,6,0,0],[0,3,4,5,6,0,0,7,0],[0,6,0,0,7,0,8,0,0],[0,7,0,0,8,9,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0]],
	[[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,1,2,3,4,5,0,0,0],[0,2,0,0,3,0,6,0,0],[0,3,4,5,6,0,0,7,0],[0,6,0,0,7,0,8,0,0],[0,7,0,0,8,9,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0]]] # En triple pour garder mes initial(e)s ^^
	
	listeJSÃ matrice(JSudoku::Vector{Vector{Int}}) = hcat(JSudoku...) #' en pinaillant
	jsm = listeJSÃ matrice ## mini version
	matriceÃ listeJS(mat,d=9) = [mat[:,i] for i in 1:d] #I will be back! ## mat3 aussi
	mjs = matriceÃ listeJS ## mini version
	# matriceÃ listeJS(listeJSÃ matrice(JSudoku)) == JSudoku ## Logique, non ?
	nbcm(mat) = count(>(0), mat ) # Nombre de chiffres > 0 dans une matrice
	nbcj(ljs) = count(>(0), listeJSÃ matrice(ljs) ) # idem pour une liste JS

	kelcarrÃ©(i::Int,j::Int) = 1+ 3*div(i-1,3) + div(j-1,3) # nÂ° du carrÃ© du sudoku
	carrÃ©(i::Int,j::Int)= 1+div(i-1,3)*3:3+div(i-1,3)*3, 1+div(j-1,3)*3:3+div(j-1,3)*3 # permet de fabriquer les filtres pour ne regarder qu'un seul carrÃ©
	carr(i::Int)= 1+div(i-1,3)*3:3+div(i-1,3)*3 # filtre carrÃ© Ã  moiti    Ã© !
	vues(mat::Array{Int,2},i::Int,j::Int)= (view(mat,i,:), view(mat,:,j), view(mat,carr(i),carr(j)) ) # liste des chiffres possible par lignes, colonnes, carrÃ©s
	listecarrÃ©(mat::Array{Int,2})= [view(mat,carr(i),carr(j)) for i in 1:3:9 for j in 1:3:9] # La liste de tous les carrÃ©s du sudoku
	tuplecarrÃ©(ii::UnitRange{Int},jj::UnitRange{Int} #=,setij::Set{Tuple{Int,Int}}=#)= [(i,j) for i in ii, j in jj] #if (i,j) âˆ‰ setij]
	simplechiffrePossible(mat::Array{Int,2},i::Int,j::Int)= setdiff(set19,view(mat,i,:), view(mat,:,j), view(mat,carr(i),carr(j))) # case en i,j
# setdiff(set19,vues(mat,i,j)...) # Pour une case en i,j
	chiffrePossible(mat::Array{Int,2},i::Int,j::Int,limp::Set{Int}, ii=carr(i)::UnitRange{Int}, jj=carr(j)::UnitRange{Int})= setdiff(set19,limp,view(mat,i,:), view(mat,:,j), view(mat, ii,jj)) # Pour une case en i,j, ii, jj

	function vÃ©rifSudokuBon(mat::Array{Int,2}) # VÃ©rifie si le sudoku est rÃ©glo
		lescarrÃ©s = listecarrÃ©(mat)
		for x in 1:9 # Pour tous les chiffres de 1 Ã  9...
			for i in 1:9 # ...est-il en doublon dans une ligne ou une colonne ?
				if count(==(x), mat[i,:])>1 || count(==(x), mat[:,i])>1
					return false
				end
			end
			for c in lescarrÃ©s # ...est-il en doublon dans un carrÃ© ?
				if count(==(x), c)>1
					return false
				end
			end
		end
		return true # Le sudoku semble conforme (mais il peut Ãªtre impossible)
	end 
	function sac(n::Int,l::Int,k::Int,ii::UnitRange{Int},jj::UnitRange{Int}, listepossibles::Set{Int}, fusibles::Dict{Int, Set{Int}},dico::Dict{Int,Dict{Int,Int}}, dilo::Dict{Int,Dict{Int,Tuple{Int,UnitRange{Int},UnitRange{Int}} }}, diko::Dict{Int,Dict{Int,Int}}) # compte l'occurence d'un chiffre pour... cf. uniclk
	 # pour ligne et colonne
	 get!(dico, n, Dict{Int,Int}() ) # dico : posibilitÃ©s par colonne/ligne
	 get!(dilo, n, Dict{Int,Tuple{Int,UnitRange{Int},UnitRange{Int}} }() ) # dilo : ligne/colonne â™»
	 get!(diko, n, Dict{Int,Int}() ) # diko : carrÃ© qui devra suppr. la possibilitÃ©
	 get!(fusibles, n, Set{Int}() ) # fusibles : nÂ° dÃ©jÃ  grillÃ©s
	 for ne in setdiff(listepossibles,fusibles[n]) #
		dico[n][ne] = get(dico[n], ne, 0) + 1
		if dico[n][ne] == 1 
			diko[n][ne] = k 
			dilo[n][ne] = (l, ii, jj)
		elseif dico[n][ne] > 3 || diko[n][ne] != k 
			push!(fusibles[n], ne) 
			delete!(dico[n], ne) 
		end
	 end
	end
	function sak(i::Int,j::Int,k::Int,ii::UnitRange{Int},jj::UnitRange{Int}, listepossibles::Set{Int},fusibles::Dict{Int, Set{Int}}, dilo::Dict{Int,Dict{Int,Tuple{Int,UnitRange{Int}} }}, dico::Dict{Int,Dict{Int,Tuple{Int,UnitRange{Int}} }}, diko::Dict{Int,Dict{Int,Int}}) 
	 # idem pour les karrÃ©s ;)
	 get!(diko, k, Dict{Int,Int}() ) # diko : possibilitÃ© par karrÃ©
	 get!(dico, k, Dict{Int,Tuple{Int,UnitRange{Int}} }() ) # dico : colonne â™»
	 get!(dilo, k, Dict{Int,Tuple{Int,UnitRange{Int}} }() ) # dilo : ligne â™»
	 get!(fusibles, k, Set{Int}() ) # fusibles : nÂ° dÃ©jÃ  grillÃ©s
	 for ne in setdiff(listepossibles,fusibles[k]) #
		diko[k][ne] = get(diko[k], ne, 0) + 1
		if diko[k][ne] == 1 
			dico[k][ne] = (j, ii)
			dilo[k][ne] = (i, jj)
		elseif diko[k][ne] > 3 || (dico[k][ne][1] != j && dilo[k][ne][1] != i)
			push!(fusibles[k], ne) 
			delete!(diko[k], ne) 
		elseif dico[k][ne][1] != j
			dico[k][ne] = (0 , 0:0) # pas pour la colonne
		elseif dilo[k][ne][1] != i
			dilo[k][ne] = (0 , 0:0) # pas pour la ligne
		end
	 end
	end
	function uniclk(diclo::Dict{Int, Dict{Int,Tuple{Int,UnitRange{Int},UnitRange{Int}}}} ,dicco::Dict{Int, Dict{Int,Int}},dicko::Dict{Int, Dict{Int,Int}},dillo::Dict{Int, Dict{Int,Int}},dilco::Dict{Int, Dict{Int,Tuple{Int,UnitRange{Int},UnitRange{Int}}}},dilko::Dict{Int, Dict{Int,Int}},diklo::Dict{Int, Dict{Int,Tuple{Int,UnitRange{Int}}}},dikco::Dict{Int, Dict{Int,Tuple{Int,UnitRange{Int}}}},dikko::Dict{Int, Dict{Int,Int}},mat::Array{Int,2},dimp::Dict{Tuple{Int,Int}, Set{Int}},dicorÃ©zlig::Dict{Int, Set{Int}}, dicorÃ©zcol::Dict{Int, Set{Int}}, dicorÃ©zcar::Dict{Int, Set{Tuple{Int,Int}}},lesZÃ©rosÃ Suppr::Set{Tuple{Int,Int,Int,UnitRange{Int},UnitRange{Int}}},Ã§aNavancePas::Bool) #... voir si un chiffre est seul (ou uniquement sur une mÃªme ligne, col...). Car par exemple, s'il apparaÃ®t une seule fois sur la ligne : c'est qu'il ne peut qu'Ãªtre lÃ  ^^
# Et par exemple, si dans une ligne, il n'y a des occurences que dans un des 3 carrÃ©, il ne pourra pas Ãªtre ailleurs dans le carrÃ©.
	 for (j,dc) in dicco # pour les colonnes
		for (n,v) in dc
			if v == 1
				mat[diclo[j][n][1],j] = n
				push!(lesZÃ©rosÃ Suppr, (diclo[j][n][1],j,dicko[j][n],diclo[j][n][2],diclo[j][n][3]))
				delete!(dicorÃ©zlig[diclo[j][n][1]],j)
				delete!(dicorÃ©zcol[j],diclo[j][n][1])
				delete!(dicorÃ©zcar[dicko[j][n]],(diclo[j][n][1],j) )
				haskey(dillo,diclo[j][n][1]) && delete!(dillo[diclo[j][n][1]], n)
				haskey(dikko,dicko[j][n]) && delete!(dikko[dicko[j][n]], n)
				Ã§aNavancePas = false # Car on a rÃ©ussi Ã  remplir
			else 
				for (lig,col) in setdiff(dicorÃ©zcar[dicko[j][n]], ((i,j) for i in diclo[j][n][2]))
					push!(get!(dimp,(lig,col),Set{Int}() ), n) # Ã§aNavancePas & dimp ?
				end
			end
		end
	 end
	 for (i,dl) in dillo # pour les lignes
		for (n,v) in dl
			if v == 1
				mat[i,dilco[i][n][1]] = n
				push!(lesZÃ©rosÃ Suppr, (i,dilco[i][n][1],dilko[i][n],dilco[i][n][2],dilco[i][n][3]))
				delete!(dicorÃ©zlig[i],dilco[i][n][1])
				delete!(dicorÃ©zcol[dilco[i][n][1]],i)
				delete!(dicorÃ©zcar[dilko[i][n]],(i,dilco[i][n][1]) )
				# haskey(dicco,dico[i][n][1]) && delete!(dicco[dico[i][n][1]], n) #sio
				haskey(dikko,dilko[i][n]) && delete!(dikko[dilko[i][n]], n)
				Ã§aNavancePas = false # Car on a rÃ©ussi Ã  remplir
			else 
				for (lig,col) in setdiff(dicorÃ©zcar[dilko[i][n]], ((i,j) for j in dilco[i][n][3]))
					push!(get!(dimp,(lig,col),Set{Int}() ), n)
				end
			end
		end
	 end
	 for (k,dk) in dikko # pour les karrÃ©
		for (n,v) in dk
			if v == 1
				mat[diklo[k][n][1],dikco[k][n][1]] = n
				push!(lesZÃ©rosÃ Suppr, (diklo[k][n][1],dikco[k][n][1],k,dikco[k][n][2],diklo[k][n][2]))
				delete!(dicorÃ©zlig[diklo[k][n][1]],dikco[k][n][1])
				delete!(dicorÃ©zcol[dikco[k][n][1]],diklo[k][n][1])
				delete!(dicorÃ©zcar[k],(diklo[k][n][1],dikco[k][n][1]) )
				# haskey(dillo,dilo[k][n][1]) && delete!(dillo[dilo[k][n][1]], n) #sio
				# haskey(dicco,dico[k][n][1]) && delete!(dicco[dico[k][n][1]], n) #rde
				Ã§aNavancePas = false # Car on a rÃ©ussi Ã  remplir
			else 
				if dikco[k][n][1] == 0 
					for col in setdiff(dicorÃ©zlig[diklo[k][n][1]], diklo[k][n][2])
						push!(get!(dimp,(diklo[k][n][1],col),Set{Int}() ), n)
					end
				else
					for lig in setdiff(dicorÃ©zcol[dikco[k][n][1]], dikco[k][n][2])
						push!(get!(dimp,(lig,dikco[k][n][1]),Set{Int}() ), n)
					end
				end
			end
		end
	 end
	 return Ã§aNavancePas
	end
	function LUniclk(diclo::Dict{Int, Dict{Int,Tuple{Int,UnitRange{Int},UnitRange{Int}}}} ,dicco::Dict{Int, Dict{Int,Int}},dicko::Dict{Int, Dict{Int,Int}},dillo::Dict{Int, Dict{Int,Int}},dilco::Dict{Int, Dict{Int,Tuple{Int,UnitRange{Int},UnitRange{Int}}}},dilko::Dict{Int, Dict{Int,Int}},diklo::Dict{Int, Dict{Int,Tuple{Int,UnitRange{Int}}}},dikco::Dict{Int, Dict{Int,Tuple{Int,UnitRange{Int}}}},dikko::Dict{Int, Dict{Int,Int}},dimp::Dict{Tuple{Int,Int}, Set{Int}}) # uniclk pour htmlSudokuPropal
	 for (j,dc) in dicco # pour les colonnes
		for (n,v) in dc
			if v == 1
				# (diclo[j][n][1],j,dicko[j][n],diclo[j][n][2],diclo[j][n][3])
				i, k, ii, jj = diclo[j][n][1],dicko[j][n],diclo[j][n][2],diclo[j][n][3]
				for iii in 1:9 # ...on retire sur la ligne et la colonne
					get!(dimp,(i,iii),Set{Int}() )
					get!(dimp,(iii,j),Set{Int}() )
					iii != j && push!(dimp[i,iii],n)
					iii != i && push!(dimp[iii,j],n)
				end
				for jjj in jj, iii in ii # ...et sur le carrÃ©
					jjj != j && iii != i && push!(get!(dimp,(iii,jjj),Set{Int}() ),n)
				end
				haskey(dillo,diclo[j][n][1]) && delete!(dillo[diclo[j][n][1]], n)
				haskey(dikko,dicko[j][n]) && delete!(dikko[dicko[j][n]], n)
				# Ã§aNavancePas = false # Car on a rÃ©ussi Ã  remplir
			else 
				for (lig,col) in setdiff(tuplecarrÃ©(diclo[j][n][2],diclo[j][n][3]), ((i,j) for i in diclo[j][n][2]))
					push!(get!(dimp,(lig,col),Set{Int}() ), n) # Ã§aNavancePas & dimp ?
				end
			end
		end
	 end
	 for (i,dl) in dillo # pour les lignes
		for (n,v) in dl
			if v == 1
				# (i,dilco[i][n][1],dilko[i][n],dilco[i][n][2],dilco[i][n][3])
				j, k, ii, jj = dilco[i][n][1],dilko[i][n],dilco[i][n][2],dilco[i][n][3]
				for iii in 1:9 # ...on retire sur la ligne et la colonne
					get!(dimp,(i,iii),Set{Int}() )
					get!(dimp,(iii,j),Set{Int}() )
					iii != j && push!(dimp[i,iii],n)
					iii != i && push!(dimp[iii,j],n)
				end
				for jjj in jj, iii in ii # ...et sur le carrÃ©
					jjj != j && iii != i && push!(get!(dimp,(iii,jjj),Set{Int}() ),n)
				end
				# haskey(dicco,dico[i][n][1]) && delete!(dicco[dico[i][n][1]], n) #sio
				haskey(dikko,dilko[i][n]) && delete!(dikko[dilko[i][n]], n)
				# Ã§aNavancePas = false # Car on a rÃ©ussi Ã  remplir
			else 
				for (lig,col) in setdiff(tuplecarrÃ©(dilco[i][n][2],dilco[i][n][3]), ((i,j) for j in dilco[i][n][3]))
					push!(get!(dimp,(lig,col),Set{Int}() ), n)
				end
			end
		end
	 end
	 for (k,dk) in dikko # pour les karrÃ©
		for (n,v) in dk
			if v == 1
				# (diklo[k][n][1],dikco[k][n][1],k,dikco[k][n][2],diklo[k][n][2])
				i, j, ii, jj = diklo[k][n][1],dikco[k][n][1],dikco[k][n][2],diklo[k][n][2]
				for iii in 1:9 # ...on retire sur la ligne et la colonne
					get!(dimp,(i,iii),Set{Int}() )
					get!(dimp,(iii,j),Set{Int}() )
					iii != j && push!(dimp[i,iii],n)
					iii != i && push!(dimp[iii,j],n)
				end
				for jjj in jj, iii in ii # ...et sur le carrÃ©
					jjj != j && iii != i && push!(get!(dimp,(iii,jjj),Set{Int}() ),n)
				end
				# haskey(dillo,dilo[k][n][1]) && delete!(dillo[dilo[k][n][1]], n) #sio
				# haskey(dicco,dico[k][n][1]) && delete!(dicco[dico[k][n][1]], n) #rde
				# Ã§aNavancePas = false # Car on a rÃ©ussi Ã  remplir
			else 
				if dikco[k][n][1] == 0 
					for col in setdiff(set19, diklo[k][n][2])
						push!(get!(dimp,(diklo[k][n][1],col),Set{Int}() ), n)
					end
				else
					for lig in setdiff(set19, dikco[k][n][2])
						push!(get!(dimp,(lig,dikco[k][n][1]),Set{Int}() ), n)
					end
				end
			end
		end
	 end
	 # return Ã§aNavancePas
	 return nothing
	end
	function pasAssezDePropal!(i::Int,j::Int, listepossibles::Set{Int},dictCheckLi::Dict{Set{Int}, Set{Int}},dictCheckCj::Dict{Set{Int}, Set{Int}},dictCheckCarrÃ©::Dict{Set{Int}, Set{Tuple{Int,Int}}},Nimp::Dict{Tuple{Int,Int}, Set{Int}},karrÃ©::Int=kelcarrÃ©(i,j), ii::UnitRange{Int}=carr(i), jj::UnitRange{Int}=carr(j), setlig::Set{Int}=set19, setcol::Set{Int}=set19, setcar::Set{Tuple{Int,Int}}=Set(tuplecarrÃ©(ii,jj)) ) 
	# Ici l'idÃ©e est de voir s'il y a plus chiffres Ã  mettre que de cases : en regardant tout ! entre deux cases, trois cases... sur la ligne, colonne, carrÃ© ^^
	# Bref, s'il n'y a pas assez de propositions pour les chiffres Ã  caser c'est vrai
	# C'est pas faux : donc Ã§a va. 
	# De plus, si un (ensemble de) chiffre est possible que sur certaines cellules, cela le retire du reste (en gardant via la matrice Nimp). Par exemple, sur une ligne, on a 1 Ã  8, la derniÃ¨re cellule ne peut que Ãªtre 9 -> grÃ¢ce Ã  Nimp, on retire le 9 des possibilitÃ©s de toutes les cellules de la colonne, du carrÃ© (et de la ligne...) sauf pour cette derniÃ¨re cellule justement ^^
	# Cela permet de limiter les possibilitÃ©s pour Ã©viter au mieux les culs de sac
	# Etant quand-mÃªme un peu trop lourd, il faut l'utiliser que si besoin
			
		for (k,v) in copy(dictCheckCj) # dico # Pour les colonnes
			kk = union(k,listepossibles)
			if length(kk) > length(v)
				vv = union(v, Set(i), get(dictCheckCj, kk, Set{Int}() )) 
				if length(kk) == length(vv)
					# Les chiffres kk sont Ã  retirer de toute la colonne sauf aux kk
					for limp in setdiff(setcol, vv)
						union!(get!(Nimp,(limp,j),Set{Int}() ), kk)
					end
				end
				dictCheckCj[kk] = vv
			else 
				return true
			end
		end	
		for (k,v) in copy(dictCheckLi) # dili # Pour les lignes
			kk = union(k,listepossibles)
			if length(kk) > length(v)
				vv = union(v, Set(j), get(dictCheckLi, kk, Set{Int}() ) ) 
				if length(kk) == length(vv)
					# Les chiffres kk sont Ã  retirer de toute la ligne sauf aux kk 
					for limp in setdiff(setlig, vv)
						union!(get!(Nimp,(i,limp),Set{Int}() ), kk)
					end
				end
				dictCheckLi[kk] = vv
			else 
				return true
			end
		end
		for (k,v) in copy(dictCheckCarrÃ©) # dica # Pour les carrÃ©s
			kk = union(k,listepossibles)
			if length(kk) > length(v)
				vv = union(v, Set([(i,j)]), get(dictCheckCarrÃ©, kk, Set{Tuple{Int,Int}}() ) ) 
				if length(kk) == length(vv)
					for (limp,ljmp) in setdiff(setcar, vv) # tuplecarrÃ©(ii,jj,vv)
						union!(get!(Nimp,(limp,ljmp),Set{Int}() ), kk)
					end
				end
				dictCheckCarrÃ©[kk] = vv
			else 
				return true
			end
		end	
		get!(dictCheckLi,listepossibles, Set( j ) )
		get!(dictCheckCj,listepossibles, Set( i ) )
		get!(dictCheckCarrÃ©,listepossibles, Set( [(i,j)] ) )
		return false
	end
	function puces(liste, valdÃ©faut=nothing ; idPuces="p"*string(rand(Int)), classe="") # Permet de faire des puces en HTML pour faire un choix unique
	# Si "ğŸ¤«Â CachÃ©e" cochÃ©e, cela floute les puces du dessous (PossiblesEtSolution)
		dÃ©but = """<span id="$idPuces" """ *(classe=="" ? ">" : """class="$classe">""")
		fin = """</span><script>const form = document.getElementById('$idPuces')
	form.oninput = (e) => { form.value = e.target.value; """ *
		(idPuces=="CacherRÃ©sultat" ? raw"""if (e.target.value=='ğŸ¤«Â CachÃ©e') {
		document.getElementById('PossiblesEtSolution').classList.add('pasla');
		document.getElementById('puchoixÃ mettreenhaut').classList.add('pasla');
		} else {
		document.getElementById('PossiblesEtSolution').classList.remove('pasla');
		document.getElementById('puchoixÃ mettreenhaut').classList.remove('pasla');
		};""" : "") *
		(idPuces=="PossiblesEtSolution" ? raw"""if (e.target.value=='â€¦de possibilitÃ©s (minÂ âœ”)') {
		document.getElementById('puchoixÃ mettreenhaut').classList.add('maistesou');
		} else {
		document.getElementById('puchoixÃ mettreenhaut').classList.remove('maistesou');
		};""" : "") * """}
	</script>"""
		inputs = ""
		for item in liste
			inputs *= """<span style="display:inline-block;"><input type="radio" id="$idPuces$item" name="$idPuces" value="$item" style="margin: O 4px 0 4px;" $(item == valdÃ©faut ? "checked" : "")><label style="margin: 0 18px 0 2px; user-select: none;" for="$idPuces$item">$item</label></span>"""
		end
		# for (item,valeur) in liste ### si liste::Array{Pair{String,String},1}
		# 	inputs *= """<input type="radio" id="$idPuces$item" name="$idPuces" value="$item" style="margin: 0 4px 0 20px;" $(item == valdÃ©faut ? "checked" : "")><label for="$idPuces$item">$valeur</label>"""
		# end
		return HTML(dÃ©but * inputs * fin)
	end
	vaetvient = HTML(raw"""
<script>
var vieillecopie = false;

function dÃ©jÃ vu() { 
	var pÃ¨re = document.getElementById("sudokincipit").parentElement;
	var fils = document.getElementById("copiefinie");
	var ancien = document.getElementById("sudokufini");
	if (vieillecopie.isEqualNode(ancien)) {
		ancien.innerHTML = fils.innerHTML;
		ancien.removeChild(ancien.querySelector("tfoot"));
		msga(ancien);
	}
	document.getElementById("sudokincipit").hidden = false;
	pÃ¨re.removeChild(fils);
	document.getElementById("va_et_vient").innerHTML = `Sudoku initialÂ â¤´ (modifiable) et sa solutionÂ : `
};

function lÃ haut() { 
	var pÃ¨re = document.getElementById("sudokincipit").parentElement;
	var fils = document.getElementById("copiefinie");
	var copie = document.getElementById("sudokufini");
	fils ? pÃ¨re.removeChild( fils ) : true;
	document.getElementById("sudokincipit").hidden = true;
	var tabl = document.createElement("table");
	vieillecopie = (copie ? copie.cloneNode(true) : tabl);
	tabl.id = "copiefinie";
	tabl.innerHTML = (copie ? copie.innerHTML : `<thead id='taide'><tr><td style='text-align: center;min-width: 340px;padding: 26px 0;'>Rien Ã  montrer, c'est cochÃ©Â Â <code>ğŸ¤«Â CachÃ©e</code></td></tr></thead>`) + `<tfoot id='tesfoot'><tr id='lignenonvisible'><th colspan="9">â†ª Cliquer ici pour revenir au sudoku modifiable</th></tr></tfoot>`;
	pÃ¨re.appendChild(tabl);
	document.getElementById("taide") ? document.getElementById("taide").addEventListener("click", dÃ©jÃ vu) : true;
	document.getElementById("tesfoot").addEventListener("click", dÃ©jÃ vu);
	copie ? msga(document.getElementById("copiefinie")) : true;
	document.getElementById("va_et_vient").innerHTML = `SolutionÂ â†‘ (au lieu du sudoku modifiableÂ initial)`
};
document.getElementById("va_et_vient").addEventListener("click", lÃ haut);

</script><span id="va_et_vient">""") # Pour le texte entre les deux sudoku (initaux et solution). Cela permet de remonter la solution en cliquant dessus

	function htmlSudoku(JSudokuFini=jsvd(),JSudokuini=jsvd() ; toutVoir=true)
	# Pour sortir de la matrice (conversion en tableau en HTML) du sudoku
	# Le JSudokuini permet de mettre les chiffres en bleu (savoir d'oÃ¹ l'on vient)
	# Enfin, on peut choisir de voir petit Ã  petit en cliquant ou toutVoir d'un coup
		if isa(JSudokuFini, String)
			return HTML("<h5 style='text-align: center;'> âš¡ Attention, sudoku initial Ã  revoir ! </h5><table id='sudokufini' style='user-select: none;' <tbody><tr><td style='text-align: center;min-width: 340px;padding: 26px 0;'>$JSudokuFini</td></tr></tbody></table>")
		else
			return HTML(raw"""<script id="scriptfini">
		// stylÃ©lÃ basavecbonus!
				
		const createSudokuHtml = (values, values_ini) => {	
		  const data = [];
		  const htmlData = [];
		  for(let i=0; i<9;i++){
			let htmlRow = [];
			data.push([]);
			for(let j=0; j<9;j++){
			  const valuesLine = values[i];
			  const value = valuesLine?valuesLine[j]:0;
				const isInitial = values_ini[i][j]>0;
				// j'ai sabrÃ© volontairement cette partie ğŸ˜„
			  const block = [Math.floor(i/3), Math.floor(j/3)];
			  const isEven = ((block[0]+block[1])%2 === 0);
			  const isMedium = (j%3 === 0);
			  const htmlCell = html`<td class='"""*(toutVoir ? raw"""${isInitial?"norbleu ":"norblanc "}""" : raw"""${isInitial?"norbleu ":"grandblur blur "}""")*raw"""${isEven?"even-color":"odd-color"}' ${isMedium?'style="border-style:solid !important; border-left-width:medium !important;"':''} data-row='${i}' data-col='${j}'>${(value||'')}</td>`; // modifiÃ© lÃ©gÃ¨rement
			  data[i][j] = value||0;
			  htmlRow.push(htmlCell);
			}
			const isMediumBis = (i%3 === 0);
    		htmlData.push(html`<tr ${isMediumBis?'style="border-style:solid !important; border-top-width:medium !important;"':''}>${htmlRow}</tr>`);
		  }
		  const _sudoku = html`<table id="sudokufini" """*(toutVoir ? "" : raw"""style="user-select: none;" """)*raw""">
			  <tbody>${htmlData}</tbody>
			</table>`  
		  // return {_sudoku,data};
		return _sudoku;
				};
		window.msga = (_sudoku) => {
				"""*(toutVoir ? raw""" 
		let tds = _sudoku.querySelectorAll('td.norblanc');
  		tds.forEach(td => {
				
			td.addEventListener('click', (e) => {
				if (document.getElementById("choixÃ mettreenhaut")) {
					if (document.getElementById("choixÃ mettreenhaut").checked) {
						const lign = parseInt(e.target.getAttribute("data-row")) + 1;
						const colo = parseInt(e.target.getAttribute("data-col")) + 1;
						const vale = e.target.innerHTML;
						var cible = document.querySelector("#sudokincipit > tbody > tr:nth-child("+ lign +") > td:nth-child("+ colo +") > input[type=text]");
						if (!(isNaN(vale))) {
							cible.value = vale; 
							// document.getElementById("tesfoot") ? document.getElementById("tesfoot").dispatchEvent(new Event('click')) : true;
							cible.dispatchEvent(new Event('ctop')); 
						};
				}}; 
				
			});
		});""" : raw"""
		let tdbleus = _sudoku.querySelectorAll('td.norbleu');
  		tdbleus.forEach(tdbleu => {
			tdbleu.addEventListener('click', (e) => {
				var grantb = e.target.parentElement.parentElement;
				for(let grani=0; grani<9;grani++){ 
				for(let granj=0; granj<9;granj++){ 
				 if ( !(grantb.childNodes[grani].childNodes[granj].classList.contains("norbleu")) ) {
				grantb.childNodes[grani].childNodes[granj].classList.add("blur");
				
				} }};
			});
		});
		
		let tds = _sudoku.querySelectorAll('td.grandblur');
  		tds.forEach(td => {
				
			td.addEventListener('click', (e) => {
				e.target.classList.toggle("blur");
					
				if (document.getElementById("choixÃ mettreenhaut")) {
					if (document.getElementById("choixÃ mettreenhaut").checked) {
						const lign = parseInt(e.target.getAttribute("data-row")) + 1;
						const colo = parseInt(e.target.getAttribute("data-col")) + 1;
						const vale = e.target.innerHTML;
						var cible = document.querySelector("#sudokincipit > tbody > tr:nth-child("+ lign +") > td:nth-child("+ colo +") > input[type=text]");
						if (!(isNaN(vale))) {
							cible.value = vale; 
							// document.getElementById("tesfoot") ? document.getElementById("tesfoot").dispatchEvent(new Event('click')) : true;
							cible.dispatchEvent(new Event('ctop')); 
						};
				}}; 
				
			});
		});	""")*raw"""
				
		  return _sudoku;

		};
		
		// sinon : return createSudokuHtml(...)._sudoku;
		return msga(createSudokuHtml(""" *"$JSudokuFini"*", "*"$JSudokuini"*""") );
		</script>""")
		end
	end
	htmls = htmlSudoku ## mini version (ou alias plus court si besoin)
	htmat = htmlSudoku âˆ˜ matriceÃ listeJS ## mini version
	
	function chiffrePropal(mat,limp,i,j) # Remplit une case avec tous ses chiffres possibles, en mettant le 1 en haut Ã  gauche et le 9 en bas Ã  droite (le 5 est donc au centre). S'il n'y a aucune possibilitÃ©, on remplit tout avec des caractÃ¨res bizarres â€½
	# Pour mise en forme en HTML mat3 : 3x3 (une matrice de 3 lignes et 3 colonnes)
		cp = chiffrePossible(mat,i,j,limp)
		if isempty(cp)
			return [["â—œ","â€½","â—"],["Â¡","/","!"],["â—Ÿ","_","â—"]]
		end
		return matriceÃ listeJS(reshape([((x in cp) ? string(x) : "Â ") for x in 1:9], (3,3)),3)
	end
	const pt1 = "Â·" # "." ## CaractÃ¨res de remplissage pour mieux voir le nbPropal
	const pt2 = "â—Œ" # "â—‹" # "â—˜" # "-" # ":"
	const pt3 = "â—" # "â– " # "â–¬" # "â€”" # "â–" # "â«¶"
	function nbPropal(mat,limp,i,j) # Assez proche de chiffrePropal ci-dessus, mais ne montre pas les chiffres possibles. Cela montre le nombres de chiffres possibles, en remplissant petit Ã  petit avec pt1 Ã  pt3 suivant.
	# Pour mise en forme en HTML mat3 : 3x3
		lcp = length(chiffrePossible(mat,i,j,limp))
		if lcp == 0
			return [["â†˜","â†“","â†™"],["â†’","0","â†"],["â†—","â†‘","â†–"]], 0
		else
			return matriceÃ listeJS(reshape([(x == lcp ? string(x) : (x<lcp ? (lcp<4 ? pt1 : (lcp<7 ? pt2 : pt3)) : "Â ")) for x in 1:9], (3,3)),3), lcp
		end
	end
	function htmlSudokuPropal(JSudokuini=jsvd(),JSudokuFini=nothing ; toutVoir=true, parCase=true, somme=false)
	# Assez proche de htmlSudoku, mais n'a pas besoin d'avoir un sudoku rÃ©solu en entrÃ©e. En effet, il ne montre que les chiffres (ou leur nombre = somme) possibles pour le moment.
	# Il y a plusieurs cas : (cela est peutÃªtre Ã  changer)
		# toutVoir ou non : dÃ©couvre tous les cellules si toutVoir (sinon Ã  cliquer)
		# parCase : dÃ©couvre une celle cellule (sinon plusieurs)
		# somme : voir juste le nombre de possibilitÃ©, sinon, voir les possibilitÃ©s
		mS::Array{Int,2} = listeJSÃ matrice(JSudokuini)
		# mImp = [ Set{Int}() for _ = 1:9, _ = 1:9 ]
		mImp = Dict{Tuple{Int,Int}, Set{Int}}()
		while true
			nAwak = deepcopy(mImp)
			vÃ©rifligne = [ Dict{Set{Int}, Set{Int}}() for _ = 1:9 ]
			vÃ©rifcol = [ Dict{Set{Int}, Set{Int}}() for _ = 1:9 ]
			vÃ©rifcarrÃ© = [ Dict{Set{Int}, Set{Tuple{Int,Int}} }() for _ = 1:9 ]
			dillo = Dict{Int, Dict{Int,Int}}() 
			dilko = Dict{Int, Dict{Int,Int}}() 
			dicco = Dict{Int, Dict{Int,Int}}() 
			dicko = Dict{Int, Dict{Int,Int}}() 
			dikko = Dict{Int, Dict{Int,Int}}() 
			dilco = Dict{Int,Dict{Int,Tuple{Int,UnitRange{Int},UnitRange{Int}}}}()
			diclo = Dict{Int,Dict{Int,Tuple{Int,UnitRange{Int},UnitRange{Int}}}}()
			dikco = Dict{Int, Dict{Int,Tuple{Int,UnitRange{Int}} }}()
			diklo = Dict{Int, Dict{Int,Tuple{Int,UnitRange{Int}} }}()
			fusibleslig = Dict{Int, Set{Int}}()
			fusiblescol = Dict{Int, Set{Int}}()
			fusiblescar = Dict{Int, Set{Int}}()
			for j in 1:9, i in 1:9
				if mS[i,j] == 0
					get!(mImp,(i,j),Set{Int}() )
					lcp = chiffrePossible(mS,i,j,mImp[i,j])
					k = kelcarrÃ©(i,j)
					ii = carr(i)
					jj = carr(j)
					sac(j,i,k,ii,jj,lcp,fusiblescol,dicco,diclo,dicko)
					sac(i,j,k,ii,jj,lcp,fusibleslig,dillo,dilco,dilko)
					sak(i,j,k,ii,jj,lcp,fusiblescar,diklo,dikco,dikko)
					if length(lcp) == 1
						for iii in 1:9 # ...on retire sur la ligne et la colonne
							get!(mImp,(i,iii),Set{Int}() )
							get!(mImp,(iii,j),Set{Int}() )
							iii != j && union!(mImp[i,iii],lcp)
							iii != i && union!(mImp[iii,j],lcp)
						end
						# for jj in carr(j), ii in carr(i) # ...et sur le carrÃ©
						for jjj in jj, iii in ii # ...et sur le carrÃ©
							# jj != j && ii != i && union!(mImp[ii,jj],Set(lcp))
							jjj != j && iii != i && union!(get!(mImp,(iii,jjj),Set{Int}() ),lcp)
						end
					else pasAssezDePropal!(i, j, lcp, vÃ©rifligne[i], vÃ©rifcol[j], vÃ©rifcarrÃ©[k], mImp ) 
					end
				end
			end
			LUniclk(diclo,dicco,dicko,dillo,dilco,dilko,diklo,dikco,dikko,mImp)
			if mImp == nAwak
				break
			end
		end
		if somme	
			mnPropal = fill(fill( fill("0",3),3) , (9,9) )
			mine = 10
			grisemine = Tuple{Int,Int}[]
			for j in 1:9, i in 1:9
				if mS[i,j] == 0
				mnPropal[i,j], lcp = nbPropal(mS, mImp[i,j], i, j)
					if lcp < mine
						mine = lcp
						grisemine = [(i,j)]
					elseif lcp == mine
						push!(grisemine, (i,j))
					end
				end
			end
			parCase = toutVoir
			toutVoir = true
			if 0 < mine < 9
				for (i,j) in grisemine
					mnPropal[i,j][3][3] = "âœ”"
				end
			end
			JPropal = matriceÃ listeJS(mnPropal)
		else
			mPropal = fill(fill( fill("0",3),3) , (9,9) )
			for j in 1:9, i in 1:9
				if mS[i,j] == 0
					mPropal[i,j] = chiffrePropal(mS, mImp[i,j], i, j)
				end
			end
			JPropal = matriceÃ listeJS(mPropal)
		end
			
		return HTML(raw"""<script id="scriptfini">
		// stylÃ©lÃ basavecbonus!
		
		// const kelcarJS = (lig, col) => [Math.floor(lig/3), Math.floor(col/3)];
		const MMcar = (lig, col, lign, colo) => Math.floor(lig/3)==Math.floor(lign/3) && Math.floor(col/3)==Math.floor(colo/3) ;
		
		const createSudokuHtml = (mvalues, values_ini) => {	
		  const data = [];
		  const htmlData = [];
		  for(let i=0; i<9;i++){
			let htmlRow = [];
			data.push([]);
			for(let j=0; j<9;j++){
				
			  	const htmlMiniData = [];
				const isInitial = values_ini[i][j]>0;
				var mini_sudoku = values_ini[i][j];
				if (!(isInitial)) {
				  for(let pl=0; pl<3;pl++){
					let htmlMiniRow = [];
					for(let pj=0; pj<3;pj++){
					const miniValue = mvalues[i][j][pl][pj];
					const htmlMiniCell = html`<td class='mini"""*(toutVoir && parCase ? "'" : raw"""${isInitial?"'":" miniblur blur'"} """)*raw""" data-row="${pl}" data-col="${pj}">${(miniValue||'Â ')}</td>`; 
					htmlMiniRow.push(htmlMiniCell);
					}
					htmlMiniData.push(html`<tr style="border-style: none !important;">${htmlMiniRow}</tr>`);
				  }
				var mini_sudoku = html`<table class="minitab" """*(toutVoir && parCase ? "" : raw"""style="user-select: none;" """)*raw""">
			  <tbody>${htmlMiniData}</tbody>
			</table>`
				}
			  const valuee = mini_sudoku;
			  const block = [Math.floor(i/3), Math.floor(j/3)];
			  const isEven = ((block[0]+block[1])%2 === 0);
			  const isMedium = (j%3 === 0);
			  const htmlCell = html`<td class='${isInitial?"grandbleu ":""} ${isEven?"even-color":"odd-color"}' ${isMedium?'style="border-style:solid !important; border-left-width:medium !important;"':''} data-row="${i}" data-col="${j}">${(valuee||'')}</td>`;
			  data[i][j] = valuee||0;
			  htmlRow.push(htmlCell);
			}
			const isMediumBis = (i%3 === 0);
    		htmlData.push(html`<tr ${isMediumBis?'style="border-style:solid !important; border-top-width:medium !important;"':''}>${htmlRow}</tr>`);
		  }
		  const _sudoku = html`""" * (isa(JSudokuFini, String) ? raw"<h5 style='text-align: center;'> âš¡ Attention, sudoku initial Ã  revoir ! </h5>" : raw"") * """<table id="sudokufini" """*(toutVoir && parCase ? "" : raw"""style="user-select: none;" """)*raw""">
			  <tbody>${htmlData}</tbody>
			</table>`  
			
		return _sudoku;
			};
			window.msga = (_sudoku) => {
				"""*(toutVoir && parCase ? (somme ? "" : raw"""
		let tds = _sudoku.querySelectorAll('td.mini');
  		tds.forEach(td => {
			td.addEventListener('click', (e) => {
				
				if (document.getElementById("choixÃ mettreenhaut")) {
					if (document.getElementById("choixÃ mettreenhaut").checked) {
						const lign = parseInt(e.target.parentElement.parentElement.parentElement.parentElement.getAttribute('data-row')) + 1; // 3 et 3
						const colo = parseInt(e.target.parentElement.parentElement.parentElement.parentElement.getAttribute('data-col')) + 1;
						const vale = e.target.innerHTML; // pas utile dans ce cas !
						var cible = document.querySelector("#sudokincipit > tbody > tr:nth-child("+ lign +") > td:nth-child("+ colo +") > input[type=text]");
						if (!(isNaN(vale))) {
							cible.value = vale; 
							// document.getElementById("tesfoot") ? document.getElementById("tesfoot").dispatchEvent(new Event('click')) : true;
							cible.dispatchEvent(new Event('ctop')); 
						};
				}};	
				
			})});	
					""") : raw"""
		let tdbleus = _sudoku.querySelectorAll('td.grandbleu');
  		tdbleus.forEach(tdbleu => {
			tdbleu.addEventListener('click', (e) => {
				var grantb = e.target.parentElement.parentElement;
				for(let grani=0; grani<9;grani++){ 
				for(let granj=0; granj<9;granj++){ 
				 if (grantb.childNodes[grani].childNodes[granj].childNodes[0].childNodes[1]!=null) {
				for(let minii=0; minii<3;minii++){ 
				for(let minij=0; minij<3;minij++){ 
				grantb.childNodes[grani].childNodes[granj].childNodes[0].childNodes[1].childNodes[minii].childNodes[minij].classList.add("blur");
				
				}} } }};
			});
		});
				
		let tds = _sudoku.querySelectorAll('td.miniblur');
  		tds.forEach(td => {
			
			"""*(parCase ? raw"""
			td.addEventListener('click', (e) => {
				
				if (document.getElementById("choixÃ mettreenhaut")) {
					if (document.getElementById("choixÃ mettreenhaut").checked) {
						const lign = parseInt(e.target.parentElement.parentElement.parentElement.parentElement.getAttribute('data-row')) + 1; // 2 et 3
						const colo = parseInt(e.target.parentElement.parentElement.parentElement.parentElement.getAttribute('data-col')) + 1;
						const vale = e.target.innerHTML; // pas utile dans ce cas !
						var cible = document.querySelector("#sudokincipit > tbody > tr:nth-child("+ lign +") > td:nth-child("+ colo +") > input[type=text]");
						if (!(isNaN(vale))) {
							cible.value = vale; 
							// document.getElementById("tesfoot") ? document.getElementById("tesfoot").dispatchEvent(new Event('click')) : true;
							cible.dispatchEvent(new Event('ctop')); 
						};
				}};	
				
				e.target.parentElement.parentElement.childNodes.forEach(ligne => {
				  ligne.childNodes.forEach(colon => {
					colon.classList.toggle("blur");
				  });
				}); 
			});	
				""" : (toutVoir ? raw"""	
			td.addEventListener('click', (e) => {
				const ilig = e.target.getAttribute('data-row');
				const jcol = e.target.getAttribute('data-col'); 
				
				"""*(somme ? "" : raw"""if (document.getElementById("choixÃ mettreenhaut")) {
					if (document.getElementById("choixÃ mettreenhaut").checked) {
						const lign = parseInt(e.target.parentElement.parentElement.parentElement.parentElement.getAttribute('data-row')) + 1; // 3 et 1
						const colo = parseInt(e.target.parentElement.parentElement.parentElement.parentElement.getAttribute('data-col')) + 1;
						const vale = e.target.innerHTML;
						var cible = document.querySelector("#sudokincipit > tbody > tr:nth-child("+ lign +") > td:nth-child("+ colo +") > input[type=text]");
						if (!(isNaN(vale))) {
							cible.value = vale; 
							// document.getElementById("tesfoot") ? document.getElementById("tesfoot").dispatchEvent(new Event('click')) : true;
							cible.dispatchEvent(new Event('ctop')); 
						};
				}}; """)*raw"""
						e.target.parentElement.parentElement.parentElement.parentElement.parentElement.parentElement.childNodes.forEach(tr => {
					tr.childNodes.forEach(tdd => {

						if (tdd.childNodes[0].childNodes[1]!=null){
				tdd.childNodes[0].childNodes[1].childNodes[ilig].childNodes[jcol].classList.toggle("blur");
					}});
				});		
			}); """ : raw"""
			
			td.addEventListener('click', (e) => {
				const ilig = e.target.getAttribute('data-row');
				const jcol = e.target.getAttribute('data-col'); 
				const granlig = e.target.parentElement.parentElement.parentElement.parentElement.getAttribute('data-row');
				const grancol = e.target.parentElement.parentElement.parentElement.parentElement.getAttribute('data-col'); 
				const orNicar = (tlig,tcol) => MMcar(granlig,grancol,tlig,tcol);
				
				if (document.getElementById("choixÃ mettreenhaut")) {
					if (document.getElementById("choixÃ mettreenhaut").checked) {
						const lign = parseInt(granlig) + 1; // 2 et 1
						const colo = parseInt(grancol) + 1;
						const vale = e.target.innerHTML;
						var cible = document.querySelector("#sudokincipit > tbody > tr:nth-child("+ lign +") > td:nth-child("+ colo +") > input[type=text]");
						if (!(isNaN(vale))) {
							cible.value = vale; 
							// document.getElementById("tesfoot") ? document.getElementById("tesfoot").dispatchEvent(new Event('click')) : true;
							cible.dispatchEvent(new Event('ctop')); 
						};
				}}; 
						e.target.parentElement.parentElement.parentElement.parentElement.parentElement.parentElement.childNodes.forEach(tr => {
					tr.childNodes.forEach(tdd => {

						if (tdd.childNodes[0].childNodes[1]!=null) {
							for(let minii=0; minii<3;minii++){ 
							for(let minij=0; minij<3;minij++){ 
							 if (ilig==minii&&jcol==minij ) {
							tdd.childNodes[0].childNodes[1].childNodes[minii].childNodes[minij].classList.add("blur");
						}}} };

						if ((tdd.childNodes[0].childNodes[1]!=null) && (tdd.getAttribute('data-row') == granlig || tdd.getAttribute('data-col') == grancol || orNicar(tdd.getAttribute('data-row'),tdd.getAttribute('data-col')) )){

							tdd.childNodes[0].childNodes[1].childNodes[ilig].childNodes[jcol].classList.toggle("blur");
							} });
				});		
			}); """))*raw"""
	
		});	""")*raw"""
				
		  return _sudoku;

		};
		
		// sinon : return createSudokuHtml(...)._sudoku;
		return msga(createSudokuHtml(""" *"$JPropal"*", "*"$JSudokuini"*"""));
		</script>""")
	end
	htmlsp = htmlSudokuPropal ## mini version
	htmatp = htmlSudokuPropal âˆ˜ matriceÃ listeJS ## mini version
	
	interval(mini,maxi,val) = HTML("<input 
        type='range' min='$(mini)' max='$(maxi)' value='$(val)' oninput='this.nextElementSibling.value=this.value'><output>Â $(val)</output>")
	# Permet de naviguer dans l'historique (un peu limitÃ©), liÃ© aux choix Ã  faire
	###### retourverslefutur Ã  mettre dans une cellule â†“
	# lhist==1 ? (valeur = 1 ; md" Pas possible d'avancer dans le temps, merci de revoir le sudoku initial ğŸ§") : md" **Avancer dans le temps :** $(@bind valeur interval(1,lhist,1)) sur $lhist"
	## slide = slider = interval
	
######################################################################################
# Fonction pricipale qui rÃ©sout n'importe quel sudoku (mÃªme faux) ####################
## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## 
  function rÃ©soutSudokuMax(mS::Array{Int,2}, vZÃ©ros::Vector{Tuple{Int,Int,Int,UnitRange{Int},UnitRange{Int}}}, dicorÃ©zlig::Dict{Int, Set{Int}}, dicorÃ©zcol::Dict{Int, Set{Int}}, dicorÃ©zcar::Dict{Int, Set{Tuple{Int,Int}}} ; nbToursMax::Int = 81, nbEssaisMax::Int = 3, essai::Int = 1, tours::Int = 0, suiv::Vector{Int} = suivant) 
	nbTours = 0 # cela compte les tours si choisi bien (avec un lÃ©ger dÃ©calage)
	nbToursTotal = tours # le nombre qui ce programme a rÃ©ellement fait par essai
	
	# # mS::Array{Int,2} = listeJSÃ matrice(JSudoku) # Converti en vraie matrice
	# # # lesZÃ©ros = Set(shuffle!([(i,j,kelcarrÃ©(i,j),carr(i),carr(j)) for j in 1:9, i in 1:9 if mS[i,j]==0])) # Set + Fast & Furious
	# # vZÃ©ros = Vector{Tuple{Int,Int,Int,UnitRange{Int},UnitRange{Int}}}()
	# # dicorÃ©zlig = Dict{Int, Set{Int}}()
	# # dicorÃ©zcol = Dict{Int, Set{Int}}()
	# # dicorÃ©zcar = Dict{Int, Set{Tuple{Int,Int}}}()
	# # for j in 1:9, i in 1:9 
	# # 	if mS[i,j]==0
	# # 		k = kelcarrÃ©(i,j)
	# # 		push!(vZÃ©ros, (i,j,k,carr(i),carr(j)) )
	# # 		push!(get!(dicorÃ©zlig,i,Set{Int}() ),j)
	# # 		push!(get!(dicorÃ©zcol,j,Set{Int}() ),i)
	# # 		push!(get!(dicorÃ©zcar,k,Set{Tuple{Int,Int}}() ),(i,j) )
	# # 	end
	# # end # Ã  faire avant rÃ©soutSudoku ?
	lesZÃ©ros = Set(shuffle!(vZÃ©ros)) # Set ... une bonne idÃ©e (et de shuffler :) ?
	# listeHistoChoix = []  ## histoire 0
	# listeHistoMat = []  ## histoire 0
	# listeHistoToursTotal = []  ## histoire 0
	# nbHistoTot = 0  ## histoire 0
	listedechoix = Tuple{Int,Int,Int,Int,Set{Int}}[]
	listedancienneMat = Array{Int,2}[]
	listedesZÃ©ros = Set{Tuple{Int,Int,Int,UnitRange{Int},UnitRange{Int}}}[]
	leZÃ©roÃ Suppr = (0,0,0,0:0,0:0) # Tuple{Int,Int,Int,UnitRange{Int},UnitRange{Int}}
	listeTours = Int[]
	nbChoixfait = 0
	minChoixdesZÃ©ros = 10
	allerAuChoixSuivant = false
	choixPrÃ©cÃ©dent = choixAfaire = (0,0,0,0,Set{Int}()) 
	listedancienImp = Dict{Tuple{Int,Int}, Set{Int}}[] # si dicOk 
	listedicorÃ©zlig = Dict{Int, Set{Int}}[]
	listedicorÃ©zcol = Dict{Int, Set{Int}}[]
	listedicorÃ©zcar = Dict{Int, Set{Tuple{Int,Int}}}[] 
	mImp = Dict{Tuple{Int,Int}, Set{Int}}()
	Ã§aNavancePas = true # Permet de voir si rien ne se remplit en un tour
	lesZÃ©rosÃ Suppr=Set{Tuple{Int,Int,Int,UnitRange{Int},UnitRange{Int}}}()
	# if essai>1 || vÃ©rifSudokuBon(mS)
	while length(lesZÃ©ros)>0 && nbToursTotal < nbToursMax
		if !allerAuChoixSuivant
			nbTours += 1
			nbToursTotal += 1
			Ã§aNavancePas = true # reset Ã  chaque tour ? idem pour le reste ?
			minChoixdesZÃ©ros = 10
			dillo = Dict{Int, Dict{Int,Int}}() 
			dilko = Dict{Int, Dict{Int,Int}}() 
			dicco = Dict{Int, Dict{Int,Int}}() 
			dicko = Dict{Int, Dict{Int,Int}}() 
			dikko = Dict{Int, Dict{Int,Int}}() 
			dilco = Dict{Int,Dict{Int,Tuple{Int,UnitRange{Int},UnitRange{Int}}}}()
			diclo = Dict{Int,Dict{Int,Tuple{Int,UnitRange{Int},UnitRange{Int}}}}()
			dikco = Dict{Int, Dict{Int,Tuple{Int,UnitRange{Int}} }}()
			diklo = Dict{Int, Dict{Int,Tuple{Int,UnitRange{Int}} }}()
			fusibleslig = Dict{Int, Set{Int}}()
			fusiblescol = Dict{Int, Set{Int}}()
			fusiblescar = Dict{Int, Set{Int}}()
			for (i,j,k,ii,jj) in lesZÃ©ros
				listechiffre = chiffrePossible(mS,i,j,get!(mImp,(i,j),Set{Int}() ),ii,jj) 
				sac(j,i,k,ii,jj,listechiffre,fusiblescol,dicco,diclo,dicko)
				sac(i,j,k,ii,jj,listechiffre,fusibleslig,dillo,dilco,dilko)
				sak(i,j,k,ii,jj,listechiffre,fusiblescar,diklo,dikco,dikko)
				if isempty(listechiffre) ### && pasAssezDePropal!(
					allerAuChoixSuivant = true # donc mauvais choix
			lesZÃ©rosÃ Suppr=Set{Tuple{Int,Int,Int,UnitRange{Int},UnitRange{Int}}}()
					break
				elseif length(listechiffre) == 1 # L'idÃ©al, une seule possibilitÃ©
					mS[i,j]=collect(listechiffre)[1] ## avant le Set en liste
					# mS[i,j]=pop!(listechiffre) ## ne fonctionne pas
					push!(lesZÃ©rosÃ Suppr, (i,j,k,ii,jj))
					delete!(dicorÃ©zlig[i],j)
					delete!(dicorÃ©zcol[j],i)
					delete!(dicorÃ©zcar[k],(i,j) )
					haskey(dillo,i) && delete!(dillo[i], mS[i,j]) # utile et sÃ»r ?
					haskey(dicco,j) && delete!(dicco[j], mS[i,j])
					haskey(dikko,k) && delete!(dikko[k], mS[i,j])
					Ã§aNavancePas = false # Car on a rÃ©ussi Ã  remplir
				elseif Ã§aNavancePas && length(listechiffre) < minChoixdesZÃ©ros
					minChoixdesZÃ©ros = length(listechiffre)
					choixAfaire = (i,j, 1, minChoixdesZÃ©ros, listechiffre) 
					leZÃ©roÃ Suppr = (i,j,k,ii,jj) # On garde les cellules avec ... 
				end # ... le moins de choix Ã  faire, si Ã§a n'avance pas
			end
		end
		# if allerAuChoixSuivant || Ã§aNavancePas && (dImp == mImp) # autrement ^^
		if allerAuChoixSuivant || uniclk(diclo,dicco,dicko,dillo,dilco,dilko,diklo,dikco,dikko,mS,mImp,dicorÃ©zlig,dicorÃ©zcol,dicorÃ©zcar,lesZÃ©rosÃ Suppr,Ã§aNavancePas)
			if allerAuChoixSuivant # Si le choix en cours n'est pas bon
				if isempty(listedechoix) # pas de bol hein
					return " âš¡ Sudoku impossible", md"""##### âš¡ Sudoku impossible Ã  rÃ©soudre... ğŸ˜œ

	Si ce n'est pas le cas, revÃ©rifier le Sudoku initial, car celui-ci n'a pas de solution possible.

	Par exempleÂ : si une case est trop contrainte, qui attend uniquement pour la ligne un 1, et en colonne autre chiffre que 1, comme 9 â† il n'y aura donc aucune solution, car on ne peut pas mettre Ã  la fois 1 et 9 dans une seule case : c'est impossible Ã  rÃ©soudre... comme ce sudoku initial.""", 
(tour=nbTours,tt=nbToursTotal,essai=essai,noix=nbChoixfait,tours=listeTours,choix=listedechoix, zÃ©ros=listedesZÃ©ros,maths=listedancienneMat) 
# (tour=nbTours,tt=nbToursTotal,essai=essai,noix=nbChoixfait,tours=listeTours,choix=listedechoix, zÃ©ros=listedesZÃ©ros,maths=listedancienneMat ,histoix=listeHistoChoix,histrice=listeHistoMat, histour=listeHistoToursTotal,histo=nbHistoTot) ## retours d'histoires 3
				elseif choixPrÃ©cÃ©dent[3] < choixPrÃ©cÃ©dent[4] # Aller au suivant
					# push!(listeHistoMat , copy(mS)) ## histoire 1 
					# push!(listeHistoChoix , choixPrÃ©cÃ©dent) ## histoire 1 
					# push!(listeHistoToursTotal , (nbTours, nbToursTotal)) ## hi1 
					# nbHistoTot += 1 ## histoire 1
					(i,j, choix, l, lc) = choixPrÃ©cÃ©dent
					choixPrÃ©cÃ©dent = (i,j, choix+1, l, lc)
					listedechoix[nbChoixfait] = choixPrÃ©cÃ©dent
					mS = copy(listedancienneMat[nbChoixfait])
					mImp = deepcopy(listedancienImp[nbChoixfait])
					nbTours = listeTours[nbChoixfait]
					allerAuChoixSuivant = false
					mS[i,j] = pop!(lc)
					lesZÃ©ros = copy(listedesZÃ©ros[nbChoixfait])
					dicorÃ©zlig = deepcopy(listedicorÃ©zlig[nbChoixfait])
					dicorÃ©zcol = deepcopy(listedicorÃ©zcol[nbChoixfait])
					dicorÃ©zcar = deepcopy(listedicorÃ©zcar[nbChoixfait])
				elseif length(listedechoix) < 2 # pas 2 bol
					return " âš¡ Sudoku impossible", md"""##### âš¡ Sudoku impossible Ã  rÃ©soudre... ğŸ˜œ

	Si ce n'est pas le cas, revÃ©rifier le Sudoku initial, car celui-ci n'a pas de solution possible.

	Par exempleÂ : si une case est trop contrainte, qui attend uniquement pour la ligne un 1, et en colonne autre chiffre que 1, comme 9 â† il n'y aura donc aucune solution, car on ne peut pas mettre Ã  la fois 1 et 9 dans une seule case : c'est impossible Ã  rÃ©soudre... comme ce sudoku initial.""", 
(tour=nbTours,tt=nbToursTotal,essai=essai,noix=nbChoixfait,tours=listeTours,choix=listedechoix, zÃ©ros=listedesZÃ©ros,maths=listedancienneMat) 
# (tour=nbTours,tt=nbToursTotal,essai=essai,noix=nbChoixfait,tours=listeTours,choix=listedechoix, zÃ©ros=listedesZÃ©ros,maths=listedancienneMat ,histoix=listeHistoChoix,histrice=listeHistoMat, histour=listeHistoToursTotal,histo=nbHistoTot) ## retours d'histoires 3
				else # Il faut revenir d'un cran dans la liste historique
					# deleteat!(listedechoix, nbChoixfait) # pourquoi pas pop
					# pop!(listedechoix) # pourquoi pas map pop! 
					map(pop!,(listedechoix,listedancienneMat,listedancienImp, listedesZÃ©ros,listeTours,listedicorÃ©zlig,listedicorÃ©zcol,listedicorÃ©zcar))
					nbChoixfait -= 1
					choixPrÃ©cÃ©dent = listedechoix[nbChoixfait]
					nbTours = listeTours[nbChoixfait]
				end
			else # Nouveau choix Ã  faire et Ã  garder en mÃ©moire
				# push!(listeHistoMat , copy(mS)) ## histoire de 
				# push!(listeHistoChoix , choixAfaire) ## histoire 2 
				# push!(listeHistoToursTotal , (nbTours, nbToursTotal)) ## histoi2 
				# nbHistoTot += 1 ## histoire 2
				push!(listedechoix, choixAfaire) # ici pas besoin de copie
				push!(listedancienneMat , copy(mS)) # copie en dur
				push!(listedancienImp , deepcopy(mImp)) # copie en dur
				# filter!(!=(choixAfaire[6:10]), lesZÃ©ros) # On retire 
				delete!(lesZÃ©ros, leZÃ©roÃ Suppr) # On retire ceux... idem set ?
				push!(listedesZÃ©ros , copy(lesZÃ©ros)) # copie en dur aussi
				push!(listeTours, nbTours) # On garde tout en mÃ©moire
				nbChoixfait += 1

				isuppr = leZÃ©roÃ Suppr[1]
				jsuppr = leZÃ©roÃ Suppr[2]
				ksuppr = leZÃ©roÃ Suppr[3]
				# mS[choixAfaire[1:2]...] = pop!(choixAfaire[5])
				mS[isuppr, jsuppr] = pop!(choixAfaire[5])

				delete!(dicorÃ©zlig[isuppr],jsuppr)
				delete!(dicorÃ©zcol[jsuppr],isuppr)
				delete!(dicorÃ©zcar[ksuppr],(isuppr,jsuppr) )
				push!(listedicorÃ©zlig, deepcopy(dicorÃ©zlig))
				push!(listedicorÃ©zcol, deepcopy(dicorÃ©zcol))
				push!(listedicorÃ©zcar, deepcopy(dicorÃ©zcar))

				choixPrÃ©cÃ©dent = choixAfaire
			end 
		else # !Ã§aNavancePas && !allerAuChoixSuivant ## Tout va bien ici
			setdiff!(lesZÃ©ros, lesZÃ©rosÃ Suppr) # On retire ceux remplis 
			lesZÃ©rosÃ Suppr=Set{Tuple{Int,Int,Int,UnitRange{Int},UnitRange{Int}}}()
		end	
	end
# 	else return "ğŸ§ Merci de corriger ce Sudoku ;)", md"""##### ğŸ§ Merci de revoir ce sudoku, il n'est pas conforme : 
# 			En effet, il doit y avoir au moins sur une ligne ou colonne ou carrÃ©, un chiffre en double; bref au mauvais endroit ! ğŸ˜„""", 
# (tour=nbTours,tt=nbToursTotal,essai=essai,noix=nbChoixfait,tours=listeTours,choix=listedechoix, zÃ©ros=listedesZÃ©ros,maths=listedancienneMat) 
# # (tour=nbTours,tt=nbToursTotal,essai=essai,noix=nbChoixfait,tours=listeTours,choix=listedechoix, zÃ©ros=listedesZÃ©ros,maths=listedancienneMat ,histoix=listeHistoChoix,histrice=listeHistoMat, histour=listeHistoToursTotal,histo=nbHistoTot) ## retours d'histoires 3
# 	end
	if essai > nbEssaisMax
		return "ğŸ¥¶ Merci de mettre un peu plus de chiffres... sudoku sÃ»rement impossible ;)", md"""##### ğŸ¥¶ Merci de mettre plus de chiffres ;) 
			
		En effet, bien que ce [Plutoku](https://github.com/4LD/plutoku) est quasi-parfait* ğŸ˜„, certains cas (trÃ¨s rare bien sÃ»r) peuvent mettre du temps (plus de 3 secondes) que je vous Ã©pargne ;)
		
		Il y a de forte chance que votre sudoku soit impossible... sinon, merci de me le signaler, car normalement ce cas arrive moins souvent que gagner au Loto ^^ 
		
		_* Sauf erreur de votre humble serviteur_""", 
(tour=nbTours,tt=nbToursTotal,essai=essai,noix=nbChoixfait,tours=listeTours,choix=listedechoix, zÃ©ros=listedesZÃ©ros,maths=listedancienneMat) 
# (tour=nbTours,tt=nbToursTotal,essai=essai,noix=nbChoixfait,tours=listeTours,choix=listedechoix, zÃ©ros=listedesZÃ©ros,maths=listedancienneMat ,histoix=listeHistoChoix,histrice=listeHistoMat, histour=listeHistoToursTotal,histo=nbHistoTot) ## retours d'histoires 3
	elseif nbToursTotal == nbToursMax || nbToursTotal > nbToursMax
		return rÃ©soutSudokuMax(get(listedancienneMat, 1, copy(mS)), vZÃ©ros, dicorÃ©zlig, dicorÃ©zcol, dicorÃ©zcar; tours=nbToursTotal, nbToursMax=suiv[essai], nbEssaisMax=nbEssaisMax, essai=essai+1) 
	else
		# push!(listeHistoMat , copy(mS)) ## toute l'histoire		
		# push!(listeHistoChoix , choixPrÃ©cÃ©dent) ## toute l'histoire	
		# push!(listeHistoToursTotal , (nbTours, nbToursTotal)) ## toute l'histoire 
		# nbHistoTot += 1 ## toute l'histoire	
		### return matriceÃ listeJS(mS') ## si on utilise : listeJSÃ matrice(...)'
		return matriceÃ listeJS(mS), md"**StatistiquesÂ :** il a fallu faire **$nbChoixfait choix** et **$nbTours $((nbTours>1) ? :tours : :tour)** (si on savait Ã  l'avance les bons choix), ce programme ayant fait _**$nbToursTotal $((nbToursTotal>1) ? :tours : :tour) au total**_ en $(essai) $((essai>1) ? :essais : :essai) pour rÃ©soudre ce sudoku !!! ğŸ˜ƒ", 
(tour=nbTours,tt=nbToursTotal,essai=essai,noix=nbChoixfait,tours=listeTours,choix=listedechoix, zÃ©ros=listedesZÃ©ros,maths=listedancienneMat) 
# (tour=nbTours,tt=nbToursTotal,essai=essai,noix=nbChoixfait,tours=listeTours,choix=listedechoix, zÃ©ros=listedesZÃ©ros,maths=listedancienneMat ,histoix=listeHistoChoix,histrice=listeHistoMat, histour=listeHistoToursTotal,histo=nbHistoTot) ## retours d'histoires 3
	end
  end
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
  function rÃ©soutSudoku(JSudoku::Vector{Vector{Int}} ; nbToursMax::Int = 81, nbEssaisMax::Int = 3, essai::Int = 1, tours::Int = 0, suiv::Vector{Int} = suivant) 
	nbTours = 0 # cela compte les tours si choisi bien (avec un lÃ©ger dÃ©calage)
	nbToursTotal = tours # le nombre qui ce programme a rÃ©ellement fait par essai
	
	mS::Array{Int,2} = listeJSÃ matrice(JSudoku) # Converti en vraie matrice
	lesZÃ©ros = Set(shuffle!([(i,j) for j in 1:9, i in 1:9 if mS[i,j]==0]))
	# lesZÃ©ros = Set(((i,j) for j in 1:9, i in 1:9 if mS[i,j]==0))
	# listeHistoChoix = []  ## histoire 0
	# listeHistoMat = []  ## histoire 0
	# listeHistoToursTotal = []  ## histoire 0
	# nbHistoTot = 0  ## histoire 0
	listedechoix = Tuple{Int,Int,Int,Int,Set{Int}}[]
	listedancienneMat = Array{Int,2}[]
	listedesZÃ©ros = Set{Tuple{Int,Int}}[]
	listeTours = Int[]
	nbChoixfait = 0
	minChoixdesZÃ©ros = 10
	allerAuChoixSuivant = false
	choixPrÃ©cÃ©dent = choixAfaire = (0,0,0,0,Set{Int}()) 
	Ã§aNavancePas = true # Permet de voir si rien ne se remplit en un tour
	lesZÃ©rosÃ Suppr=Set{Tuple{Int,Int}}()
	# if essai>1 || vÃ©rifSudokuBon(mS)
	if vÃ©rifSudokuBon(mS)
		while length(lesZÃ©ros)>0 && nbToursTotal < nbToursMax
			if !allerAuChoixSuivant
				nbTours += 1
				nbToursTotal += 1
				Ã§aNavancePas = true # reset Ã  chaque tour ? idem pour le reste ?
				minChoixdesZÃ©ros = 10
				for (i,j) in lesZÃ©ros
					listechiffre = simplechiffrePossible(mS,i,j) 
					if isempty(listechiffre)
						allerAuChoixSuivant = true # donc mauvais choix
						lesZÃ©rosÃ Suppr=Set{Tuple{Int,Int}}()
						break
					elseif length(listechiffre) == 1 # L'idÃ©al, une seule possibilitÃ©
						mS[i,j]=collect(listechiffre)[1] ## avant le Set en liste
						# mS[i,j]=pop!(listechiffre) ## ne fonctionne pas
						push!(lesZÃ©rosÃ Suppr, (i,j))
						Ã§aNavancePas = false # Car on a rÃ©ussi Ã  remplir
					elseif Ã§aNavancePas && length(listechiffre) < minChoixdesZÃ©ros
						minChoixdesZÃ©ros = length(listechiffre)
						choixAfaire = (i,j, 1, minChoixdesZÃ©ros, listechiffre)  
						end # ... le moins de choix Ã  faire, si Ã§a n'avance pas
				end
			end
			if allerAuChoixSuivant || Ã§aNavancePas 
				if allerAuChoixSuivant # Si le choix en cours n'est pas bon
					if isempty(listedechoix) # pas de bol hein
						return " âš¡ Sudoku impossible", md"""##### âš¡ Sudoku impossible Ã  rÃ©soudre... ğŸ˜œ
							
		Si ce n'est pas le cas, revÃ©rifier le Sudoku initial, car celui-ci n'a pas de solution possible.
							
		Par exempleÂ : si une case est trop contrainte, qui attend uniquement pour la ligne un 1, et en colonne autre chiffre que 1, comme 9 â† il n'y aura donc aucune solution, car on ne peut pas mettre Ã  la fois 1 et 9 dans une seule case : c'est impossible Ã  rÃ©soudre... comme ce sudoku initial.""", 
(tour=nbTours,tt=nbToursTotal,essai=essai,noix=nbChoixfait,tours=listeTours,choix=listedechoix, zÃ©ros=listedesZÃ©ros,maths=listedancienneMat) 
# (tour=nbTours,tt=nbToursTotal,essai=essai,noix=nbChoixfait,tours=listeTours,choix=listedechoix, zÃ©ros=listedesZÃ©ros,maths=listedancienneMat ,histoix=listeHistoChoix,histrice=listeHistoMat, histour=listeHistoToursTotal,histo=nbHistoTot) ## retours d'histoires 3
					elseif choixPrÃ©cÃ©dent[3] < choixPrÃ©cÃ©dent[4] # Aller au suivant
						# push!(listeHistoMat , copy(mS)) ## histoire 1 
						# push!(listeHistoChoix , choixPrÃ©cÃ©dent) ## histoire 1 
						# push!(listeHistoToursTotal , (nbTours, nbToursTotal)) ## hi1 
						# nbHistoTot += 1 ## histoire 1
						(i,j, choix, l, lc) = choixPrÃ©cÃ©dent
						choixPrÃ©cÃ©dent = (i,j, choix+1, l, lc)
						listedechoix[nbChoixfait] = choixPrÃ©cÃ©dent
						mS = copy(listedancienneMat[nbChoixfait])
						nbTours = listeTours[nbChoixfait]
						allerAuChoixSuivant = false
						mS[i,j] = pop!(lc)
						lesZÃ©ros = copy(listedesZÃ©ros[nbChoixfait])
					elseif length(listedechoix) < 2 # pas 2 bol
						return " âš¡ Sudoku impossible", md"""##### âš¡ Sudoku impossible Ã  rÃ©soudre... ğŸ˜œ
							
		Si ce n'est pas le cas, revÃ©rifier le Sudoku initial, car celui-ci n'a pas de solution possible.
							
		Par exempleÂ : si une case est trop contrainte, qui attend uniquement pour la ligne un 1, et en colonne autre chiffre que 1, comme 9 â† il n'y aura donc aucune solution, car on ne peut pas mettre Ã  la fois 1 et 9 dans une seule case : c'est impossible Ã  rÃ©soudre... comme ce sudoku initial.""", 
(tour=nbTours,tt=nbToursTotal,essai=essai,noix=nbChoixfait,tours=listeTours,choix=listedechoix, zÃ©ros=listedesZÃ©ros,maths=listedancienneMat) 
# (tour=nbTours,tt=nbToursTotal,essai=essai,noix=nbChoixfait,tours=listeTours,choix=listedechoix, zÃ©ros=listedesZÃ©ros,maths=listedancienneMat ,histoix=listeHistoChoix,histrice=listeHistoMat, histour=listeHistoToursTotal,histo=nbHistoTot) ## retours d'histoires 3
					else # Il faut revenir d'un cran dans la liste historique
						# deleteat!(listedechoix, nbChoixfait) # pourquoi pas pop
						# pop!(listedechoix) # pourquoi pas map pop! 
						map(pop!,(listedechoix,listedancienneMat, listedesZÃ©ros,listeTours))
						nbChoixfait -= 1
						choixPrÃ©cÃ©dent = listedechoix[nbChoixfait]
						nbTours = listeTours[nbChoixfait]
					end
				else # Nouveau choix Ã  faire et Ã  garder en mÃ©moire
					# push!(listeHistoMat , copy(mS)) ## histoire de 
					# push!(listeHistoChoix , choixAfaire) ## histoire 2 
					# push!(listeHistoToursTotal , (nbTours, nbToursTotal)) ## histoi2 
					# nbHistoTot += 1 ## histoire 2
					push!(listedechoix, choixAfaire) # ici pas besoin de copie
					push!(listedancienneMat , copy(mS)) # copie en dur
					delete!(lesZÃ©ros, choixAfaire[1:2]) # On retire ceux... idem set ?
					push!(listedesZÃ©ros , copy(lesZÃ©ros)) # copie en dur aussi
					push!(listeTours, nbTours) # On garde tout en mÃ©moire
					nbChoixfait += 1
					mS[choixAfaire[1:2]...] = pop!(choixAfaire[5])
					choixPrÃ©cÃ©dent = choixAfaire
				end 
			else # !Ã§aNavancePas && !allerAuChoixSuivant ## Tout va bien ici
				setdiff!(lesZÃ©ros, lesZÃ©rosÃ Suppr) # On retire ceux remplis 
				lesZÃ©rosÃ Suppr=Set{Tuple{Int,Int}}()
			end	
		end
	else return "ğŸ§ Merci de corriger ce Sudoku ;)", md"""##### ğŸ§ Merci de revoir ce sudoku, il n'est pas conforme : 
			En effet, il doit y avoir au moins sur une ligne ou colonne ou carrÃ©, un chiffre en double; bref au mauvais endroit ! ğŸ˜„""", 
(tour=nbTours,tt=nbToursTotal,essai=essai,noix=nbChoixfait,tours=listeTours,choix=listedechoix, zÃ©ros=listedesZÃ©ros,maths=listedancienneMat) 
# (tour=nbTours,tt=nbToursTotal,essai=essai,noix=nbChoixfait,tours=listeTours,choix=listedechoix, zÃ©ros=listedesZÃ©ros,maths=listedancienneMat ,histoix=listeHistoChoix,histrice=listeHistoMat, histour=listeHistoToursTotal,histo=nbHistoTot) ## retours d'histoires 3
	end
	if essai > nbEssaisMax
		return "ğŸ¥¶ Merci de mettre un peu plus de chiffres... sudoku sÃ»rement impossible ;)", md"""##### ğŸ¥¶ Merci de mettre plus de chiffres ;) 
			
		En effet, bien que ce [Plutoku](https://github.com/4LD/plutoku) est quasi-parfait* ğŸ˜„, certains cas (trÃ¨s rare bien sÃ»r) peuvent mettre du temps (plus de 3 secondes) que je vous Ã©pargne ;)
		
		Il y a de forte chance que votre sudoku soit impossible... sinon, merci de me le signaler, car normalement ce cas arrive moins souvent que gagner au Loto ^^ 
		
		_* Sauf erreur de votre humble serviteur_""", 
(tour=nbTours,tt=nbToursTotal,essai=essai,noix=nbChoixfait,tours=listeTours,choix=listedechoix, zÃ©ros=listedesZÃ©ros,maths=listedancienneMat) 
# (tour=nbTours,tt=nbToursTotal,essai=essai,noix=nbChoixfait,tours=listeTours,choix=listedechoix, zÃ©ros=listedesZÃ©ros,maths=listedancienneMat ,histoix=listeHistoChoix,histrice=listeHistoMat, histour=listeHistoToursTotal,histo=nbHistoTot) ## retours d'histoires 3
	elseif nbToursTotal == nbToursMax || nbToursTotal > nbToursMax
		mCopie = get(listedancienneMat, 1, copy(mS))
		vZÃ©ros = Vector{Tuple{Int,Int,Int,UnitRange{Int},UnitRange{Int}}}()
		dicorÃ©zlig = Dict{Int, Set{Int}}()
		dicorÃ©zcol = Dict{Int, Set{Int}}()
		dicorÃ©zcar = Dict{Int, Set{Tuple{Int,Int}}}()
		for j in 1:9, i in 1:9 
			if mCopie[i,j]==0
				k = kelcarrÃ©(i,j)
				push!(vZÃ©ros, (i,j,k,carr(i),carr(j)) )
				push!(get!(dicorÃ©zlig,i,Set{Int}() ),j)
				push!(get!(dicorÃ©zcol,j,Set{Int}() ),i)
				push!(get!(dicorÃ©zcar,k,Set{Tuple{Int,Int}}() ),(i,j) )
			end
		end # Ã  faire avant rÃ©soutSudoku ?
		return rÃ©soutSudokuMax(mCopie, vZÃ©ros, dicorÃ©zlig, dicorÃ©zcol, dicorÃ©zcar; tours=nbToursTotal, nbToursMax=suiv[essai], nbEssaisMax=nbEssaisMax, essai=essai+1) 
	else
		# push!(listeHistoMat , copy(mS)) ## toute l'histoire		
		# push!(listeHistoChoix , choixPrÃ©cÃ©dent) ## toute l'histoire	
		# push!(listeHistoToursTotal , (nbTours, nbToursTotal)) ## toute l'histoire 
		# nbHistoTot += 1 ## toute l'histoire	
		### return matriceÃ listeJS(mS') ## si on utilise : listeJSÃ matrice(...)'
		return matriceÃ listeJS(mS), md"**StatistiquesÂ :** il a fallu faire **$nbChoixfait choix** et **$nbTours $((nbTours>1) ? :tours : :tour)** (si on savait Ã  l'avance les bons choix), ce programme ayant fait _**$nbToursTotal $((nbToursTotal>1) ? :tours : :tour) au total**_ en $(essai) $((essai>1) ? :essais : :essai) pour rÃ©soudre ce sudoku !!! ğŸ˜ƒ", 
(tour=nbTours,tt=nbToursTotal,essai=essai,noix=nbChoixfait,tours=listeTours,choix=listedechoix, zÃ©ros=listedesZÃ©ros,maths=listedancienneMat) 
# (tour=nbTours,tt=nbToursTotal,essai=essai,noix=nbChoixfait,tours=listeTours,choix=listedechoix, zÃ©ros=listedesZÃ©ros,maths=listedancienneMat ,histoix=listeHistoChoix,histrice=listeHistoMat, histour=listeHistoToursTotal,histo=nbHistoTot) ## retours d'histoires 3
	end
  end
  rjs = rÃ©soutSudoku ## mini version   ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## 
  rmat = rÃ©soutSudoku âˆ˜ matriceÃ listeJS ## mini version   ## ## ## ## ## ## ## ## ## #
# Fin de la fonction principale : rÃ©soutSudoku  ######################################
######################################################################################

  function sudokuAlÃ©atoireFini() ## GÃ©nÃ¨re un sudoku alÃ©atoire fini (aucun vide)
	return listeJSÃ matrice(rÃ©soutSudoku(jsvd())[1])
  end
  function sudokuAlÃ©atoire(x=19:62 ; fun=rand, matzÃ©ro=sudokuAlÃ©atoireFini())#rand1:81
  # Une fois le sudokuAlÃ©atoireFini, on le vide un peu d'un nombre x de cellules
	if !isa(x, Int) # Permet de choisir le nombre de zÃ©ro ou un intervale
		x=fun(x)
	end
	x = (0 <= x < 82) ? x : 81 # Pour ceux aux gros doigts, ou qui voit trop grand
	liste = shuffle!([(i,j) for i in 1:9 for j in 1:9])
	for (i,j) in liste[1:x] # nbApproxDeZÃ©ros
		matzÃ©ro[i,j] = 0
	end
	return matriceÃ listeJS(matzÃ©ro)
  end

  function vieuxSudoku!(nouveau=sudokuAlÃ©atoire() ; dÃ©faut=false, mÃ©moire=SudokuMÃ©mo, matzÃ©ro=sudokuAlÃ©atoireFini(), idLien="lien"*string(rand(Int)))
  # On peut retrouver un vieuxSudoku! pour le mettre au lieu du sudoku initial
  ## Exemple de sudoku :
  # vieuxSudoku!([[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,3,0,8,5],[0,0,1,0,2,0,0,0,0],[0,0,0,5,0,7,0,0,0],[0,0,4,0,0,0,1,0,0],[0,9,0,0,0,0,0,0,0],[5,0,0,0,0,0,0,7,3],[0,0,2,0,1,0,0,0,0],[0,0,0,0,4,0,0,0,9]])
	if dÃ©faut==true # MÃ©galomanie ## On revient Ã  mon dÃ©faut ^^
		mÃ©moire[2] = copy(mÃ©moire[4])
	elseif isa(nouveau, Int) || isa(nouveau, UnitRange{Int})
		mÃ©moire[2] = sudokuAlÃ©atoire(nouveau ; matzÃ©ro=matzÃ©ro)
	elseif nouveau==mÃ©moire[1] 
		mÃ©moire[2] = sudokuAlÃ©atoire()
	else mÃ©moire[2] = copy(nouveau) # Astuce pour sauver le sudoku en cours
	end
	return HTML("""<script>
	var ele = document.getElementsByName("ModifierInit");
	for(var ni=0;ni<ele.length;ni++)
		ele[ni].checked = false;

	function goSudokuIni() {
		document.getElementsByName("ModifierInit")[1].click();
	}
	document.getElementById("$idLien").addEventListener("click", goSudokuIni);
	goSudokuIni();
	window.location.href = "#ModifierInit";
	</script><h6 style="margin-top: 0;"> Ci-dessous, le boutonÂ â–¶ restore le vieux sudoku en sudoku initialÂ !Â ğŸ¥³ <a id="$idLien" href='#ModifierInit'> retourÂ enÂ hautÂ â†‘ </a> </h6>""")
  end
  vieux = vs = vs! = vS! = vieuxSudoku! ## mini version
  vsd() = vieuxSudoku!(dÃ©faut=true) ## Pour revenir Ã  l'original
  ini = dÃ©faut = defaut = vsd ## mini version
  sudokuinitial!() = vieuxSudoku!(SudokuMÃ©mo[3])

  function sudokuAlt(nbChiffresMax=rand(26:81), moinsOK=true, nbessai=1) 
  # Sorte de sudokuAlÃ©atoire mais un peu plus foireux, en effet, il n'est pas forcÃ©ment rÃ©alisable. C'Ã©tait surtout pour faire des tests.
	nbChiffres = 1
	
	mS::Array{Int,2} = zeros(Int, 9,9) # Matrice de zÃ©ro
	lesZÃ©ros = shuffle!([(i,j) for j in 1:9, i in 1:9])# Fast & Furious
	
	for (i,j) in lesZÃ©ros
		if nbChiffres > nbChiffresMax
			return mS
		else 
		listechiffre = simplechiffrePossible(mS,i,j)
			if isempty(listechiffre) ### Pas bon signe ^^
				if moinsOK || nbessai > 26
					return mS
				else 
					return sudokuAlt(nbChiffresMax, false, nbessai+1)
				end
			else # length(listechiffre) == 1 # L'idÃ©al, une seule possibilitÃ©
				# mS[i,j]=collect(listechiffre)[1]
				mS[i,j]=pop!(listechiffre)
				nbChiffres += 1
			end
		end
	end
  end
  salt = sudokuAlt ## mini version

  function blindtest(nbtest=100 ; tmax=81, emax=4, emin=1, suiv=suivant, nbzÃ©ro = (rand, 7:77), sudf=sudokuAlÃ©atoireFini)
  # Permet de tester la rapiditÃ© et certains bugs de ma fonction principale rÃ©soutSudoku. C'est donc une fonction qui est technique et qui sert surtout quand il y a des Ã©volutions de cette fonction.
	nbzÃ©rof() = isa(nbzÃ©ro,Tuple) ? nbzÃ©ro=nbzÃ©ro[1](nbzÃ©ro[2]) : Nothing
	for i in 1:nbtest
		sudini = sudf()
		nbzÃ©rof()
		sudalÃ©a = sudokuAlÃ©atoire(nbzÃ©ro, fun=identity, matzÃ©ro=copy(sudini))
		# try 
		# 	rÃ©soutSudoku(sudalÃ©a ; nbToursMax=tmax,nbEssaisMax=emax,essai=emin, fsuiv=fsuiv)
		# catch e
		# 	return ("bug", e, sudalÃ©a)
		# end
		soluce = rÃ©soutSudoku(sudalÃ©a ; nbToursMax=tmax,nbEssaisMax=emax,essai=emin, suiv=suiv)
		if soluce[1] isa String
			if sudf==sudokuAlÃ©atoireFini || soluce[1] != " âš¡ Sudoku impossible"
		# if soluce[1] == " âš¡ Sudoku impossible"
		# if soluce[1] == "ğŸ§ Merci de corriger ce Sudoku ;)"
		# if soluce[1] == "ğŸ¥¶ Merci de mettre un peu plus de chiffres... sudoku sÃ»rement impossible ;)"
				return i, nbzÃ©ro, soluce, sudini, replace("vieux( $(matriceÃ listeJS(sudini)) )"," "=>""), sudalÃ©a, replace("vieux($sudalÃ©a)"," "=>"")
			end
		end
	end
	return "Tout va bien... pour le moment ğŸ‘"
  end
  bt = testme = blindtest ## mini version
######################################################################################
end; nothing; # stylÃ©lÃ basavecbonus! ## voir juste dans la cellule #Bonus au dessus â†‘
# VoilÃ  ! fin de la plupart du code de ce programme Plutoku.jl«code_foldedÃÙ$7cce8f50-2469-11eb-058a-099e8f6e3103„§cell_idÙ$7cce8f50-2469-11eb-058a-099e8f6e3103°running_disabledÂ¤codeÙubegin 
	bindJSudoku
	md"""#### $vaetvient Sudoku initialÂ â¤´ (modifiable) et sa solutionÂ : $(html"</span>") """
end«code_foldedÃÙ$81bbbd00-2c37-11eb-38a2-09eb78490a16„§cell_idÙ$81bbbd00-2c37-11eb-38a2-09eb78490a16°running_disabledÂ¤codeÚ,md"""Si besoin, dans cette session, le sudoku en cours (ci-dessous) peut rester en mÃ©moire en cliquant sur le bouton suivant : $(@bind boutonSudokuInitial html"<input type=button style='margin: 0 10px 0 10px;' value='En cours â†’ Le sudoku initial ;)'>") *(Â siÂ videÂ â†’Â sudokuÂ alÃ©atoireÂ )*"""«code_foldedÃÙ$96d2d3e0-2133-11eb-3f8b-7350f4cda025„§cell_idÙ$96d2d3e0-2133-11eb-3f8b-7350f4cda025°running_disabledÂ¤codeÚˆmd"# RÃ©soudre un Sudoku par AlexisÂ $cool" # v1.8.4Â vendrediÂ 10/09/2021Â ğŸ¶

#= Pour la vue HTML et le style CSS, cela est fortement inspirÃ© de https://github.com/Pocket-titan/DarkMode et pour le sudoku https://observablehq.com/@filipermlh/ia-sudoku-ple1
Pour basculer entre plusieurs champs automatiquement via JavaScript, merci Ã  https://stackoverflow.com/a/15595732 , https://stackoverflow.com/a/44213036 et autres
Et bien sÃ»r le calepin d'exemple de @fonsp "3. Interactivity"
Pour info, le code principal et stylÃ©lÃ basavecbonus! :)

Ce "plutoku" est visible sur https://github.com/4LD/plutoku

Pour le relancer, c'est sur https://mybinder.org/v2/gh/fonsp/pluto-on-binder/master?urlpath=pluto/open?url=https://raw.githubusercontent.com/4LD/plutoku/main/Plutoku.jl
Ou https://binder.plutojl.org/open?url=https:%252F%252Fraw.githubusercontent.com%252F4LD%252Fplutoku%252Fmain%252FPlutoku.jl =#«code_foldedÃÙ$b2cd0310-2663-11eb-11d4-49c8ce689142„§cell_idÙ$b2cd0310-2663-11eb-11d4-49c8ce689142°running_disabledÂ¤codeÚif bindJSudoku isa Missing
	sudokuSolutionVue = SudokuMÃ©mo[3] # Aucune erreur perdant le calcul...
	md"**Statistiques :** il a fallu faire **XX choix** et **YY tours** (si on savait Ã  l'avance les bons choix), ce programme ayant fait **ZZ tours** au total en Î± essai pour rÃ©soudre ce sudoku !!! ğŸ˜ƒ" # Texte bidon le temps que cela calcule ;)
else 
	SudokuMÃ©mo[3] = bindJSudoku # Pour que le sudoku en cours (initial modifiÃ©) reste en mÃ©moire si besoin -> Le sudoku initial ;) 
	sudokuSolution = rÃ©soutSudoku(bindJSudoku) # normal
	# sudokuSolution = rÃ©soutSudoku(bindJSudoku; nbToursMax=0) ## Pour ralentir ğŸŒğŸ¢
	sudokuSolutionVue = sudokuSolution[1]
	sudokuSolution[2] # La petite explication seule
end
# using BenchmarkTools
# @benchmark rÃ©soutSudoku(bindJSudoku)«code_foldedÃÙ$a038b5b0-23a1-11eb-021d-ef7de773ef0e„§cell_idÙ$a038b5b0-23a1-11eb-021d-ef7de773ef0e°running_disabledÂ¤codeÚæbegin
	viderOupas isa Missing ? viderSudoku = 2 : (viderSudoku = (viderOupas == "Vider le sudoku initial" ? 1 : 2))
	SudokuInitial = HTML("""
<script>
// stylÃ©lÃ basavecbonus!

const premier = JSON.stringify( $(SudokuMÃ©mo[1]) );
const deuxiÃ¨me = JSON.stringify( $(SudokuMÃ©mo[2]) );
const defaultFixedValues = $(SudokuMÃ©mo[viderSudoku])""" * raw"""
			
// const defaultFixedValues = [[0,0,0,7,0,0,0,0,0],[1,0,0,0,0,0,0,0,0],[0,0,0,4,3,0,2,0,0],[0,0,0,0,0,0,0,0,6],[0,0,0,5,0,9,0,0,0],[0,0,0,0,0,0,4,1,8],[0,0,0,0,8,1,0,0,0],[0,0,2,0,0,0,0,5,0],[0,4,0,0,0,0,3,0,0]];
		
window.createSudokuHtml = (values) => {
  const data = [];
  const htmlData = [];
  for(let i=0; i<9;i++){
    let htmlRow = [];
    data.push([]);
    for(let j=0; j<9;j++){
      const valuesLine = values[i];
      const value = valuesLine?valuesLine[j]:0;
      const htmlInput = html`<input  
        type='text'
        data-row='${i}'
        data-col='${j}'
        maxlength='1' 
        value='${(value||'')}'
      >`;
      const block = [Math.floor(i/3), Math.floor(j/3)];
      const isEven = ((block[0]+block[1])%2 === 0);
	  const isMedium = (j%3 === 0);
      const htmlCell = html`<td class='${isEven?"even-color":"odd-color"}' ${isMedium?'style="border-style:solid !important; border-left-width:medium !important;"':""}>${htmlInput}</td>`
      data[i][j] = value||0;
      htmlRow.push(htmlCell);
    }
	
    const isMediumBis = (i%3 === 0);
    htmlData.push(html`<tr ${isMediumBis?'style="border-style:solid !important; border-top-width:medium !important;"':""}>${htmlRow}</tr>`);
  }
  const _sudoku = html`<table id="sudokincipit" vrai="test" sudata=${JSON.stringify(data)} >
      <tbody>${htmlData}</tbody>
    </table>`  
  return {_sudoku,data};
  // // return _sudoku ;
  
}

window.sudokuViewReactiveValue = ({_sudoku:html, data}) => {
// // window.sudokuViewReactiveValue = (html) => {
// // data = JSON.parse(html.getAttribute("sudata"));
  html.addEventListener('input', (e)=>{
    e.stopPropagation();
    e.preventDefault();
    html.value = data
    return false;
  }); 
  
  let inputs = html.querySelectorAll('input');
  inputs.forEach(input => {
	
	const daligne = (e) => e.target.getAttribute('data-row');
	const dacol = (e) => e.target.getAttribute('data-col');
	const etp2 = (e) => e.target.parentElement.parentElement;
	const etp3 = (e) => e.target.parentElement.parentElement.parentElement;

	const moveDown = (e) => { 
		if (etp2(e).nextElementSibling == null) { 
		etp3(e).childNodes[0].childNodes[dacol(e)].childNodes[0].focus();
		} else { 
		etp2(e).nextElementSibling.childNodes[dacol(e)].childNodes[0].focus();
		} 
	}
	const moveUp = (e) => {
		if (etp2(e).previousElementSibling == null) { 
		etp3(e).lastChild.childNodes[dacol(e)].childNodes[0].focus();
		} else { 
		etp2(e).previousElementSibling.childNodes[dacol(e)].childNodes[0].focus();
		} 
	}
	const moveLeft = (e) => {
		if (e.target.parentElement.previousElementSibling == null) {
			if (etp2(e).previousElementSibling == null) {
				etp3(e).lastChild.lastChild.childNodes[0].focus();
			} else {
			etp2(e).previousElementSibling.lastChild.childNodes[0].focus();
		} } else {
		e.target.parentElement.previousElementSibling.childNodes[0].focus();
		} 
	}
	const moveRight = (e) => { 
		if (e.target.parentElement.nextElementSibling == null) {
			if (etp2(e).nextElementSibling == null) {
				etp3(e).childNodes[0].childNodes[0].childNodes[0].focus();
			} else {
			etp2(e).nextElementSibling.childNodes[0].childNodes[0].focus();
		} } else { 
		e.target.parentElement.nextElementSibling.childNodes[0].focus();
		} 
	}
		
	input.addEventListener('keydown',(e) => {
	  // e.target.focus();
	  e.target.select();
		
	  switch (e.key) {
		case "ArrowDown":
			moveDown(e);
			break;
		case "ArrowUp":
			moveUp(e);
			break;
		case "ArrowLeft":
			moveLeft(e);
			break;
		case "ArrowRight":
			moveRight(e);
			break;
		case "Shift":
		case "CapsLock":
		case "NumLock":
			break; // https://www.w3.org/TR/uievents-key/#keys-modifier
		case "Backspace":
		case "Delete":
			if (data[daligne(e)][dacol(e)] !== 0) {
				data[daligne(e)][dacol(e)] = 0;
				e.target.value = "";
				// Efface les puces car cela a Ã©tÃ© touchÃ©
				var ele = document.getElementsByName("ModifierInit");
				for(var ni=0;ni<ele.length;ni++)
					ele[ni].checked = false;
				const jdata = JSON.stringify(data);
				if (jdata == premier) {
					ele[0].checked = true;
				} else if (jdata == deuxiÃ¨me) {
					ele[1].checked = true;
				}
				html.setAttribute('sudata', jdata);
				html.dispatchEvent(new Event('input'));
			}
			(e.key==="Delete")?moveRight(e):moveLeft(e);
			var da = document.activeElement;
			(e.key==="Delete")?(da.selectionStart = da.selectionEnd = da.value.length):(da.selectionStart = da.selectionEnd = 0); // select KO :(
			break;
		default:
			return;
		} }) 
		
    input.addEventListener('input',(e) => {
	  const i = e.target.getAttribute('data-row'); // daligne(e)
	  const j = e.target.getAttribute('data-col'); // dacol(e)
	  const val = e.target.value //parseInt(e.target.value);
	  const oldata = data[i][j];

	  const bidouilliste = {a:1,z:2,e:3,r:4,t:5,y:6,u:7,i:8,o:9,
		A:1,Z:2,E:3,R:4,T:5,Y:6,U:7,I:8,O:9,
		'\&':1,Ã©:2,'\"':3,"\'":4,'\(':5,'\-':6,Ã¨:7,_:8,Ã§:9};

	  const androidChromeEstChiant = {'b':moveDown,'B':moveDown,
		'h':moveUp,'H':moveUp,        'j':moveRight,'J':moveRight,
		'g':moveLeft,'G':moveLeft,'v':moveLeft,'V':moveLeft,
		'd':moveRight,'D':moveRight,'n':moveRight,'N':moveRight};

	  if (val in bidouilliste) {
		e.target.value = data[i][j] = bidouilliste[val];
	  } else if (val <= 9 && val >=1) {
		data[i][j] = parseInt(val);
		} else if ((val == 0)||(val == 'Ã ')||(val == 'p')||(val == 'P')) {
		data[i][j] = 0;
		e.target.value = '';
	  } else { 
		e.target.value = data[i][j] === 0 ? '' : data[i][j];
	  }

		if (oldata === data[i][j]) {
			e.stopPropagation();
			e.preventDefault();
		} else {
			// Efface les puces car cela a Ã©tÃ© touchÃ©
			var ele = document.getElementsByName("ModifierInit");
			for(var ni=0;ni<ele.length;ni++)
				ele[ni].checked = false;
			const jdata = JSON.stringify(data);
			if (jdata == premier) {
				ele[0].checked = true;
			} else if (jdata == deuxiÃ¨me) {
				ele[1].checked = true;
			}
			html.setAttribute('sudata', jdata);
			html.dispatchEvent(new Event('input'));
		}

		if (val in androidChromeEstChiant) {
			androidChromeEstChiant[val](e);
		} else {
			moveRight(e);
		}
		document.activeElement.select();
    })
		
    input.addEventListener('ctop',(e) => { // mis Ã  jour par chiffre sÃ©lectionnÃ©
	  const i = e.target.getAttribute('data-row'); // daligne(e)
	  const j = e.target.getAttribute('data-col'); // dacol(e)
	  const val = e.target.value //parseInt(e.target.value);
	  const oldata = data[i][j];

	  if (val <= 9 && val >=1) {
		data[i][j] = parseInt(val);
	  } else { 
		e.target.value = data[i][j] === 0 ? '' : data[i][j];
	  }

		if (oldata === data[i][j]) {
			e.stopPropagation();
			e.preventDefault();
		} else {
			// Efface les puces car cela a Ã©tÃ© touchÃ©
			var ele = document.getElementsByName("ModifierInit");
			for(var ni=0;ni<ele.length;ni++)
				ele[ni].checked = false;
			const jdata = JSON.stringify(data);
			if (jdata == premier) {
				ele[0].checked = true;
			} else if (jdata == deuxiÃ¨me) {
				ele[1].checked = true;
			}
			html.setAttribute('sudata', jdata);
			html.dispatchEvent(new Event('input'));
		}
    })
		
  }) 
  var ele = document.getElementsByName("ModifierInit");
  const jdata = JSON.stringify(data);
  if (jdata == premier) {
	ele[0].checked = true;
  } else if (jdata == deuxiÃ¨me) {
	ele[1].checked = true; // ...].click(); // Ã©tait KO...
  }
  html.setAttribute('sudata', jdata);
  html.dispatchEvent(new Event('input'));
  return html;

};

return sudokuViewReactiveValue(createSudokuHtml(defaultFixedValues));
</script>""")
	@bind bindJSudoku SudokuInitial
end«code_foldedÃ«notebook_idÙ$f34703d0-36a2-11ec-0393-cb5f106dd932«in_temp_dirÂ